
################################## SuSiF UTILITY FUNCTIONS ############################
#'
#'
#'
#'@title Initialise the prior
#'
#'@description generate list of object corresponding to the parameters of the prior set for analysis
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@param prior Three choice are available "normal", "mixture_normal", "mixture_normal_per_scale"
#'@param indx_lst list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return an object of the class "normal", "mixture_normal" or "mixture_normal_per_scale"

init_prior <- function(Y,X, prior,v1 , indx_lst )
{
  if( prior == "mixture_normal")
  {

    temp <- cal_Bhat_Shat(Y,X,v1 )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function

    G_prior <- list()
    G_prior[[1]]  <-  ash(c(temp$Bhat), c(temp$Shat),mixcompdist ="normal")
    attr(G_prior, "class") <- "foo" <- "mixture_normal"
  }

  if( prior == "mixture_normal_per_scale")
  {

    temp <- cal_Bhat_Shat(Y,X,v1 )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function
    G_prior  <-  lapply(1: (log2(dim(Y)[2])+1) ,
                        FUN= function(s) fit_ash_level(  Bhat=temp$Bhat, temp$Shat,s=s, indx_lst ) )
    #first log2(Y_f)+1 element of G_prior   are ash prior fitted per level coefficient on var 1
    # element in  (log2(Y_f)+2):  2*( log2(Y_f)+1)   of G_prior   are ash prior fitted per level coefficient on var 2

    attr(G_prior, "class") <- "mixture_normal_per_scale"
  }

  return(G_prior)

}




#'@title Regress Y nxJ on X nxp
#'
#'@description regression coefficients (and sd) of the column wise regression
#'
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@return list of two
#'
#'\item{Bhat} matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'\item{Shat} matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
cal_Bhat_Shat <- function(Y,X,v1 )
{
  Bhat  <- list()
  Shat  <- list()

  for ( l in 1:dim(Y)[2])
  {
    out <-  do.call( cbind,lapply( 1:dim(X)[2], function(j) fit_lm(l= l,j=j, Y=Y,X=X, v1=v1  ) ) )
    Bhat[[l]]  <- out[1,]
    Shat[[l]] <- out[2,]
  }

  Bhat <- (do.call(cbind, Bhat))
  Shat <- (do.call(cbind, Shat))
  out  <- list( Bhat = Bhat,
                Shat = Shat)
  return(out)
}



#'@title Regress column l of Y on column j of X
#'
#'@description
#'
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@return vector of 2 containing the regression coefficient and standard

fit_lm <- function( l,j,Y,X,v1)  ## Speed Gain
{

  out <- lmfit(cbind(v1,X[,j]),Y[,l])
  return(c(out$be[2,1],
           sqrt(
             var(out$residuals)/sum(
               (X[,j]-mean(X[,j]))^2)
           )
  )
  )

}


#'@title Fit ash of coefficient from scale s
#'
#'@description  #'
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param s scale of interest
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return an ash object

fit_ash_level <- function(Bhat, Shat,s,indx_lst)
{
  out <- ash(c(Bhat[, indx_lst[[s]] ]),
             c(Shat[, indx_lst[[s]] ])
             ,mixcompdist ="normal"
            )
  return(out)
}



#'@title Compute log Bayes Factor under mixture normal prior
#'
#'@description  #'
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return p log Bayes factor

log_BF.mixture_normal  <- function( G_prior  ,Bhat,Shat, indx_lst, ...)
{
  t_col_post <- function(t ){


    m <- (G_prior [[1]]   )

    m$fitted_g$pi
    tt <-  rep(0, length(Shat[t,  ]))
    pi_k <- m$fitted_g$pi
    sd_k <- m$fitted_g$sd
    for( k in 1:length( m$fitted_g$pi))  ## Speed Gain #could potential skip the one that are exactly 0
    {

      tt <- tt+ pi_k[k]*dnorm(Bhat[t,  ], sd= sqrt(sd_k[k]^2 +Shat[t,  ]^2))

    }
    out <- sum (log(tt) -   log(dnorm(  Bhat[t,  ],sd= Shat[t,  ])))

    return( out )
  }
  out <- lapply( 1:(dim(X)[2]),
                 FUN= t_col_post)

  return(do.call(c, out))
}

#'@title Compute log Bayes Factor under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return p log Bayes factor


log_BF.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ... )
{
  t_col_post <- function(t ){

    t_s_post <- function(s){
      m <- G_prior  [[s]] ## Speed Gain #could potential skip the one that are exactly 0


      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(calc_logLR (get_fitted_g(m),data))
    }
    return(sum(unlist(lapply(1:(log2(dim(Bhat)[2] )  ),#important to maintain the ordering of the wavethresh package !!!!
                             t_s_post ))))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)
  return(do.call(c, out))
}





#'@title Compute posterior mean under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior mean


post_mat_mean.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t,] ,Shat[t,] )
    return(postmean(get_fitted_g(m),data))
  }

  out <- lapply(1:(dim(Bhat)[2] ),t_col_post )

  return(do.call(cbind, out))
}



#'@title Compute posterior mean under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior mean


post_mat_mean.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_m_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(postmean(get_fitted_g(m),data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_m_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(do.call(cbind, out)))
}








#'@title Compute posterior standard deviation under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior standard deviation


post_mat_sd.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t, ] ,Shat[t, ] )
    return(postsd(get_fitted_g(m),data))
  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

  return(do.call(cbind, out))
}



#'@title Compute posterior standard deviation under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior standard deviation


post_mat_sd.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_sd_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(postsd(get_fitted_g(m),data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_sd_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(do.call(cbind, out)))
}


#'@title EM algorithm to find Empirical Bayes prior under the mixture normal prior
#'
#'
#'let try to make similar for the different prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@param max_step numeric, maximum number of EM iteration
#'@param espsilon numeric, tolerance EM algorithm
#'@return
#'
#'\item tpi_k fitted mixture proportion
#'\item lBF log Bayes Factor


EM_pi  <- function(G_prior,Bhat, Shat, indx_lst,
                                 max_step =100,
                                 espsilon =0.0001 ){

  #static parameters
  L_mixsq <-  L_mixsq(G_prior, Bhat, Shat, indx_lst)

  #dynamic parameters
  tpi_k= get_pi_G_prior(G_prior)## need method here) ## need method here
  tsd_k= get_sd_G_prior(G_prior) ## need method here
  J <- dim(Bhat)[1]
  oldloglik <-0
  newloglik <-1
  n_wav_coef <- dim(Bhat)[2]
  zeta <- rep(1/J,J) #assignation
  k <- 1 #counting the number of iteration

  lBF <- get_log_BF(G_prior,Bhat,Shat, indx_lst)
  if( prod(is.finite(lBF) )==0) #avoid extreme overflow problem when little noise is present
  {
    lBF <-  ifelse(lBF==Inf,max(10000, 10*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <-  ifelse(lBF== -Inf,max(-10000, -10*max(lBF[-which(lBF== -Inf)])),lBF)
  }

  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    ###E step----
    #easier to plug into  a apply function
    #but pi_k, sd_k have to be updated at every loop


    oldloglik <- sum( zeta*exp(lBF - max(lBF ) ))
    zeta <- exp(lBF - max(lBF ) ) /sum( exp(lBF - max(lBF ) ))

    #zeta are the assignement proba/weight afterwards

    ####M step ---

    w <- rep(zeta,  n_wav_coef) #setting the weight to fit the wieghted ash problem
    tlength <- dim(L_mixsq)[2]-1
    out.mixsqp <- mixsqp(L_mixsq,
                         w,
                         log=TRUE,
                         x0 = c(1, rep(1e-30,  tlength )),
                         control = list(eps = 1e-6,
                                        numiter.em = 20,
                                        verbose=FALSE
                         )
    )
    tpi_k <- out.mixsqp$x


    lBF <- do.call(c,lapply(1:J,e_log_BF_mix ))
    if( prod(is.finite(lBF) )==0) #avoid extrem overflow problem when little noise is present
    {
      lBF <-  ifelse(lBF==Inf,max(1000, 10*max(lBF[-which(lBF==Inf)])),lBF)
      lBF <-  ifelse(lBF== -Inf,max(-1000, -10*max(lBF[-which(lBF== -Inf)])),lBF)
    }
    newloglik <- sum( zeta*exp(lBF - max(lBF ) ))


    k <- k+1

  }
  out =list (tpi_k=tpi_k,
             lBF =lBF )
  return(out )
}



#'@title Compute likelihood matrix for mixsqp under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return See L argument mixsqp package mixsqp function


L_mixsq.mixture_normal <- function(G_prior,Bhat, Shat, indx_lst)
{
  m     <-  (G_prior[[1]])
  sdmat <- sqrt(outer(c(Shat ^2),get_sd_G_prior(G_prior)^2,"+"))
  L     <- (
            dnorm(
                  outer(
                        c(Bhat),
                        rep(0,length(get_sd_G_prior(G_prior))),
                       FUN="-"
                       )/sdmat,
                  log=TRUE
                  ) -log(sdmat )
            )

  class(L) <- "lik_mixture_normal"
  return(L)
}



#'@title Compute likelihood matrix for mixsqp under mixture  normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return List of L matrix (see L argument mixsqp package mixsqp function)


L_mixsq.mixture_normal_per_scale <- function(G_prior,Bhat, Shat, indx_lst)
{
  L  <- lapply(1:length(indx_lst  ) , function(s) cal_L_mixsq_s_per_scale (G_prior,s, Bhat, Shat, indx_lst))

  class(L) <- "lik_mixture_normal_per_scale"
  return(L)
}

#'@title Sub routine to compute likelihood matrix at scale s for mixsqp under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param s scale where the likelihood matrix should be computed
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return L see L argument mixsqp package mixsqp function

cal_L_mixsq_s_per_scale <- function(G_prior,s, Bhat, Shat ,indx_lst)
{
  m <-  (G_prior[[s]])
  sdmat <-sqrt(outer(c(Shat[,indx_lst[[s]]]^2),get_sd_G_prior(G_prior)[[s]]^2,"+"))
  L = (dnorm(outer(c(Bhat[,indx_lst[[s]]]),m$fitted_g$mean,FUN="-")/sdmat,log=TRUE) -log(sdmat ))
  return(L)
}





m_step.lik_mixture_normal <- function(L, w)
{
  out <- mixsqp(L_mixsq,
                w,
                log=TRUE,
                x0 = c(1, rep(1e-30,  tlength )),
                control = list(eps = 1e-6,
                               numiter.em = 20,
                               verbose=FALSE
                              )
                 )
  return(out)
}


m_step.lik_mixture_normal_per_scale <- function(L,zeta){
  #setting the weight to fit the wieghted ash problem
  scale_mixsqp <- function(s)
  {
    w <- rep(zeta,length(indx_lst[[s]] ))
    tlength <- dim(L_mixsq_scale[[s]])[2]-1
    return(mixsqp( L_mixsq_scale[[s]] ,
                   w,
                   x0 = c(1, rep(1e-30,  tlength )),
                   log=TRUE ,
                   control = list(
                     eps = 1e-6,
                     numiter.em = 20,
                     verbose=FALSE
                   )
    )$x
    )

  }

  out.mixsqp <- lapply(1:length(indx_lst) , scale_mixsqp)
}



################################## SuSiF UTILITY FUNCTIONS ############################
#'
#'
#'
#'@title Initialise the prior
#'
#'@description generate list of object corresponding to the parameters of the prior set for analysis
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@param prior Three choice are available "normal", "mixture_normal", "mixture_normal_per_scale"
#'@param indx_lst list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return an object of the class "normal", "mixture_normal" or "mixture_normal_per_scale"
#'@export
init_prior <- function(Y,X, prior,v1 , indx_lst )
{
  if( prior == "mixture_normal")
  {

    temp <- cal_Bhat_Shat(Y,X,v1 )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function

    G_prior <- list()
    G_prior[[1]]  <-  ash(c(temp$Bhat), c(temp$Shat),mixcompdist ="normal")
    attr(G_prior, "class") <- "foo" <- "mixture_normal"
  }

  if( prior == "mixture_normal_per_scale")
  {

    temp <- cal_Bhat_Shat(Y,X,v1 )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function
    G_prior  <-  lapply(1: (log2(dim(Y)[2])+1) ,
                        FUN= function(s) fit_ash_level(  Bhat=temp$Bhat, temp$Shat,s=s, indx_lst ) )
    #first log2(Y_f)+1 element of G_prior   are ash prior fitted per level coefficient on var 1
    # element in  (log2(Y_f)+2):  2*( log2(Y_f)+1)   of G_prior   are ash prior fitted per level coefficient on var 2

    attr(G_prior, "class") <- "mixture_normal_per_scale"
  }

  return(G_prior)

}


#'@title EM algorithm to find Empirical Bayes prior
#'@description
#'@param G_prior mixture normal prior  or mixture  normal per scale
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@param max_step numeric, maximum number of EM iteration
#'@param espsilon numeric, tolerance EM algorithm
#'@return
#'
#'\item tpi_k fitted mixture proportion
#'\item lBF log Bayes Factor
#'@export
EM_pi  <- function(G_prior,Bhat, Shat, indx_lst,
                   max_step =100,
                   espsilon =0.0001 ){

  #static parameters
  L  <-  L_mixsq(G_prior, Bhat, Shat, indx_lst)
  J <- dim(Bhat)[1]
  tsd_k = get_sd_G_prior(G_prior)

  #dynamic parameters
  tpi_k = get_pi_G_prior(G_prior)
  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration

  lBF <- log_BF(G_prior,Bhat,Shat, indx_lst)

  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    ###E step----
    oldloglik <- cal_lik(lBF,zeta )
    zeta <- cal_zeta(lBF)
    ####M step ----
    tpi_k <- m_step(L,zeta, indx_lst)
    G_prior <- update_prior(G_prior, tpi_k)

    lBF <- log_BF(G_prior,Bhat,Shat, indx_lst)
    newloglik <- cal_lik(lBF,zeta )
    k <- k+1

  }
  out =list (tpi_k=tpi_k,
             lBF =lBF )
  return(out )
}




#'@title Regress Y nxJ on X nxp
#'
#'@description regression coefficients (and sd) of the column wise regression
#'
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@return list of two
#'
#'\item{Bhat} matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'\item{Shat} matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@export
cal_Bhat_Shat <- function(Y,X,v1 )
{
  Bhat  <- list()
  Shat  <- list()

  for ( l in 1:dim(Y)[2])
  {
    out <-  do.call( cbind,lapply( 1:dim(X)[2], function(j) fit_lm(l= l,j=j, Y=Y,X=X, v1=v1  ) ) )
    Bhat[[l]]  <- out[1,]
    Shat[[l]] <- out[2,]
  }

  Bhat <- (do.call(cbind, Bhat))
  Shat <- (do.call(cbind, Shat))
  out  <- list( Bhat = Bhat,
                Shat = Shat)
  return(out)
}



#'@title Regress column l of Y on column j of X
#'
#'@description
#'
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@return vector of 2 containing the regression coefficient and standard
#'@export
fit_lm <- function( l,j,Y,X,v1)  ## Speed Gain
{

  out <- lmfit(cbind(v1,X[,j]),Y[,l])
  return(c(out$be[2,1],
           sqrt(
             var(out$residuals)/sum(
               (X[,j]-mean(X[,j]))^2)
           )
  )
  )

}


#'@title Fit ash of coefficient from scale s
#'
#'@description  #'
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param s scale of interest
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return an ash object
#'@export
fit_ash_level <- function(Bhat, Shat,s,indx_lst)
{
  out <- ash(c(Bhat[, indx_lst[[s]] ]),
             c(Shat[, indx_lst[[s]] ])
             ,mixcompdist ="normal"
            )
  return(out)
}



#'@title Compute log Bayes Factor under mixture normal prior
#'
#'@description  #'
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return p log Bayes factor
#'@export
log_BF.mixture_normal  <- function( G_prior  ,Bhat,Shat, indx_lst, ...)
{
  t_col_post <- function(t ){


    m <- (G_prior [[1]]   )

    m$fitted_g$pi
    tt <-  rep(0, length(Shat[t,  ]))
    pi_k <- m$fitted_g$pi
    sd_k <- m$fitted_g$sd
    for( k in 1:length( m$fitted_g$pi))  ## Speed Gain #could potential skip the one that are exactly 0
    {

      tt <- tt+ pi_k[k]*dnorm(Bhat[t,  ], sd= sqrt(sd_k[k]^2 +Shat[t,  ]^2))

    }
    out <- sum (log(tt) -   log(dnorm(  Bhat[t,  ],sd= Shat[t,  ])))

    return( out )
  }
  out <- lapply( 1:(dim(X)[2]),
                 FUN= t_col_post)
  lBF <- do.call(c, out)
  if( prod(is.finite(lBF) )==0) #avoid extrem overflow problem when little noise is present
  {
    lBF <-  ifelse(lBF==Inf,max(10000, 100*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <-  ifelse(lBF== -Inf,max(-10000, -100*max(lBF[-which(lBF== -Inf)])),lBF)
  }
  return(lBF)
}

#'@title Compute log Bayes Factor under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return p log Bayes factor
#'@export
log_BF.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ... )
{
  t_col_post <- function(t ){

    t_s_post <- function(s){
      m <- G_prior  [[s]] ## Speed Gain #could potential skip the one that are exactly 0


      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(calc_logLR (get_fitted_g(m),data))
    }
    return(sum(unlist(lapply(1:(log2(dim(Bhat)[2] )  ),#important to maintain the ordering of the wavethresh package !!!!
                             t_s_post ))))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)
  lBF <- do.call(c, out)
  if( prod(is.finite(lBF) )==0) #avoid extrem overflow problem when little noise is present
  {
    lBF <-  ifelse(lBF==Inf,max(10000, 100*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <-  ifelse(lBF== -Inf,max(-10000, -100*max(lBF[-which(lBF== -Inf)])),lBF)
  }
  return(lBF)
}





#'@title Compute posterior mean under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior mean
#'@export
post_mat_mean.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t,] ,Shat[t,] )
    return(postmean(get_fitted_g(m),data))
  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

  return(t(do.call(cbind, out)))
}



#'@title Compute posterior mean under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior mean
#'@export
post_mat_mean.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_m_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(postmean(get_fitted_g(m),data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_m_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(do.call(cbind, out)))
}








#'@title Compute posterior standard deviation under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior standard deviation
#'@export
post_mat_sd.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t, ] ,Shat[t, ] )
    return(postsd(get_fitted_g(m),data))
  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

  return(t(do.call(cbind, out)))
}



#'@title Compute posterior standard deviation under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior standard deviation
#'@export
post_mat_sd.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_sd_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(postsd(get_fitted_g(m),data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_sd_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(do.call(cbind, out)))
}



#'@title Compute likelihood matrix for mixsqp under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return See L argument mixsqp package mixsqp function
#'@export
L_mixsq.mixture_normal <- function(G_prior,Bhat, Shat, indx_lst)
{
  m     <-  (G_prior[[1]])
  sdmat <- sqrt(outer(c(Shat ^2),get_sd_G_prior(G_prior)^2,"+"))
  L     <- (
            dnorm(
                  outer(
                        c(Bhat),
                        rep(0,length(get_sd_G_prior(G_prior))),
                       FUN="-"
                       )/sdmat,
                  log=TRUE
                  ) -log(sdmat )
            )

  class(L) <- "lik_mixture_normal"
  return(L)
}



#'@title Compute likelihood matrix for mixsqp under mixture  normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return List of L matrix (see L argument mixsqp package mixsqp function)
#'@export

L_mixsq.mixture_normal_per_scale <- function(G_prior,Bhat, Shat, indx_lst)
{
  L  <- lapply(1:length(indx_lst  ) , function(s) cal_L_mixsq_s_per_scale (G_prior,s, Bhat, Shat, indx_lst))

  class(L) <- "lik_mixture_normal_per_scale"
  return(L)
}

#'@title Sub routine to compute likelihood matrix at scale s for mixsqp under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param s scale where the likelihood matrix should be computed
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return L see L argument mixsqp package mixsqp function
#'@export
cal_L_mixsq_s_per_scale <- function(G_prior,s, Bhat, Shat ,indx_lst)
{
  m <-  (G_prior[[s]])
  sdmat <-sqrt(outer(c(Shat[,indx_lst[[s]]]^2),get_sd_G_prior(G_prior)[[s]]^2,"+"))
  L = (dnorm(outer(c(Bhat[,indx_lst[[s]]]),m$fitted_g$mean,FUN="-")/sdmat,log=TRUE) -log(sdmat ))
  return(L)
}




#'@title Compute M step in the wieghted ash problem for normal mixture prior
#'@description
#'@param L output of L_mixsqp function
#'@param zeta assignment probabilities for each covariate
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return a vector of proportion (class pi_mixture_normal)
#'@export
m_step.lik_mixture_normal <- function(L, zeta, indx_lst)
{
  w <- rep( zeta,sum(lengths(indx_lst))) #setting the weight to fit the weighted ash problem
  tlength <- dim(L)[2]-1
  mixsqp_out <- mixsqp(L,
                w,
                log=TRUE,
                x0 = c(1, rep(1e-30,  tlength )),# put starting point close to sparse solution
                control = list(
                               eps = 1e-6,
                               numiter.em = 20,
                               verbose=FALSE
                              )
                 )
  out <- mixsqp_out$x
  class( out ) <-  "pi_mixture_normal"
  return(out)
}


#'@title Compute M step in the weighted ash problem for normal mixture prior
#'@description
#'@param L output of L_mixsqp function
#'@param zeta assignment probabilities for each covariate
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return a list if vector of proportion (class pi_mixture_normal_per_scale)
#'@export
m_step.lik_mixture_normal_per_scale <- function(L, zeta, indx_lst)
{
   #setting the weight to fit the wieghted ash problem


  out <- lapply(1:length(indx_lst) ,
                       function(s) scale_m_step(L,s,zeta,indx_lst)
                       )
  class( out ) <-  "pi_mixture_normal_per_scale"
  return(out)

}



#'@title Subroutine to compute M step in the weighted ash problem for normal mixture prior per scale at a given scale s
#'@description
#'@param L output of the L_mixsqp.mixture_normal_per_scale function
#'@param s scale
#'@param zeta assignment probabilities for each covariate
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return a vector of proportion for the scale s
scale_m_step <- function(L,s,zeta, indx_lst)
{
  w <- rep(zeta,length(indx_lst[[s]] ))
  tlength <- dim(L[[s]])[2]-1
  mixsqp_out <- mixsqp( L[[s]] ,
                        w,
                        x0 = c(1, rep(1e-30,  tlength )),
                        log=TRUE ,
                        control = list(
                                        eps = 1e-6,
                                        numiter.em = 20,
                                        verbose=FALSE
                                      )
  )

  out <- mixsqp_out$x
  return( out)

}
#'@title Compute assignment probabilities from log Bayes factors
#'@description
#'@param lBF vector of log Bayes factors
cal_zeta <- function(lBF)
{
  out <- exp(lBF - max(lBF ) ) /sum( exp(lBF - max(lBF ) ))
  return(out)
}

#'@title Compute likelihood for the weighted ash problem
#'@description
#'@param lBF vector of log Bayes factors
#'@param zeta assignement probabilities
#'@return Likelihood value
#'@export
cal_lik <- function(lBF,zeta)
{
  out <- sum( zeta*exp(lBF - max(lBF ) ))
  return(out)
}



#'@title Update mixture proportion for mixture normal prior
#'@description
#'@param G a prior of class "mixture_normal"
#'@param tpi a vector of proportion of class"pi_mixture_normal"
#'@return a prior of class "mixture_normal"
#'@export
update_prior.mixture_normal <- function(G_prior, tpi)
{
  if( class(tpi)=="pi_mixture_normal"){
    G_prior <- G_prior[[1]]$fitted_g$pi <- tpi
  }else{
    stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(G_prior)
}


#'@title Update mixture proportion for mixture normal prior
#'@description
#'@param G a prior of class "mixture_normal"
#'@param tpi a vector of proportion of class"pi_mixture_normal"
#'@return a prior of class "mixture_normal"
#'@export
update_prior.mixture_normal <- function(G_prior, tpi)
{
  if( class(tpi)=="pi_mixture_normal"){
    G_prior[[1]] <- update_ash_pi(G_prior[[1]], tpi)
  }else{
    stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(G_prior)
}

#'@title Update mixture proportion for mixture normal per scale prior
#'@description
#'@param G a prior of class "mixture_normal_per_scale"
#'@param tpi a vector of proportion of class"pi_mixture_normal_per_scale"
#'@return a prior of class "mixture_normal_per_scale"
#'@export
update_prior.mixture_normal_per_scale <- function(G_prior, tpi)
{
  if( class(tpi)=="pi_mixture_normal_per_scale"){
    out <- mapply(update_ash_pi ,G_prior, tpi, SIMPLIFY = FALSE)
    class(out ) <- "mixture_normal_per_scale"
  }else{
    stop("Error: tpi is not of class pi_mixture_normal_per_scale,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(out)
}

#'@title Update ash object mixture proportion
#'@description
#'@param G a ash object
#'@param tpi a vector of proportion
#'@return an ash object with updated mixture proportion
#'@export
update_ash_pi<- function(G , tpi)
{

  if( length(G$fitted_g$pi )==length(tpi))
  {
    G$fitted_g$pi <- tpi
  }else{
    stop("Error: when updating ash object length of new mixture proportion
    \nlonger than the mixture proportion in the ash object    ")

  }

  return(G)
}


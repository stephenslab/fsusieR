
library(tidyverse)
#library(mvsusieR)
library(rlist)

library(dae)
library(mvtnorm)
#library(pROC)
library(wavethresh)
library(parallel)
library(susiF.alpha)
library(dplyr)
##### 0.05 PVE ---------

res_out <- list()
#set.seed(1)
for (i in (length(res_out)+1):10000){
  genotype_file_dir = "/home/wdenault/fsusi_simu/sim/Yuqi_data/genotype_data"
  v_random = 0.7
  add_profile_baseline = 0# whether add baseline for each CpG site
  corr_type = 2
  num_block = 2
  off_diag_corr = 0.8
  rho = 0.9
  L = 3 # true effect
  pve = 0.05 ### WD change here -----
  # proportion variance explained by genotype
  seg_id_cur = 1
  methy_map_path = "~/../../Volumes/Yuqi_Backup/Projects/Research_data/neuro-mQTL/OmicsSIMLA/profile/methylation/WGBS/map.txt"
  methy_profile_path = "~/../../Volumes/Yuqi_Backup/Projects/Research_data/neuro-mQTL/OmicsSIMLA/profile/methylation/WGBS/cortexAD_profile.txt"
  log2_reg_leng = 7
  # main functions ----
  data_generation = function(seg_tib, geno_info,
                             L, pve, add_profile_baseline, v_random,
                             scenario = "mvn", # options: nig, ash
                             # mvn parameter
                             corr_type = 1,
                             num_block = 2, off_diag_corr = 1, # block
                             rho = 0.99, # decay
                             # nig parameter
                             tau = 0.9, #para decay wavelet coefficient
                             alpha = 0, #decay coefficient
                             eta = 0.5, gamma = 0.8, #transition
                             sigma = 0.2,     # variance
                             # ash parameter
                             mode = "vanilla",
                             pi0 = NA
  ){
    # chose true mQTLs from segment candidates ----
    input_list = input_tidy(seg_tib = seg_tib, geno_info = geno_info, L = L)
    # generate b_j  and formulate B matrix
    if(scenario == "mvn"){
      geno_effect = effect_mvn(input_obj = input_list, v_random = v_random, pve = pve/L,
                               corr_type = corr_type,
                               num_block = num_block, off_diag_corr = off_diag_corr,
                               rho = rho)
    }else if(scenario == "nig"){
      geno_effect = effect_nig(input_obj = input_list, v_random = v_random, pve = pve/L,
                               tau = tau, alpha = alpha, #decay coefficient
                               eta = eta, gamma = gamma #transition
      )
    }else if(scenario == "ash"){
      geno_effect = effect_ash(input_obj = input_list, v_random = v_random, pve = pve/L,
                               mode = mode, pi0 = pi0)
    }

    # generate random variance ----
    N = dim(input_list$X)[1]
    R = length(input_list$Y0)
    E = random_variance(n_samp = N, R = R, v_random = v_random)
    # Y = XB+E+Y0
    Y = geno_effect$XB+E

    if(add_profile_baseline){
      Y0 = input_list$Y0
      Y0[Y0 == 0] = 1e-10 # qnorm(0) = -inf
      Y0[Y0==1] = 1-1e-10 # qnorm(1) = inf, avoid influence from baseline
      Y = t(t(Y)+qnorm(Y0,0,1))
    }

    # output tidy up
    data_list = list(Y = Y,
                     mqtl = input_list$mqtl,
                     b_vec = geno_effect$b_vec_list,
                     X = input_list$X,
                     emp_pi0 = geno_effect$emp_pi0, # for ash
                     oracle_cov = geno_effect$cov # for mvn and nig
    )
    return(data_list)
  }


  # utils ----
  # find geno position to be analyzed in sampled segment
  chosen_seg_and_find_geno = function(methy_profile,geno_ann,seg_id_cur, mode = "cis_window"){
    if(mode == "cis_window"){
      methy_profile %>%
        filter(seg_id == seg_id_cur) %>%
        group_by(seg_id) %>%
        mutate(geno_blk = map2(left_window,right_window,
                               function(l,r){
                                 geno_ann %>%
                                   filter(pos>=l & pos <= r) %>%
                                   pull(SNP) # attention! the geno_blk saving the postion of the SNPs
                               } )) %>%
        dplyr::select(-c(left_window, right_window)) %>%
        ungroup(seg_id) %>%
        mutate(geno_size = map_dbl(geno_blk,length)) %>% # see how many snps are selected
        filter(geno_size>10 & geno_size<1000)## only remain those blks with appropriate sizes of SNPs to be analysed
    }else if(mode == "nearest_100"){
      methy_profile %>%
        filter(seg_id == seg_id_cur) %>%
        nest(data=-seg_id) %>%
        mutate(geno_blk = map(data, function(dat){
          center = median(dat$start)
          dist2center = abs(as.numeric(geno_ann$pos)-center)
          nearest100 = geno_ann$SNP[sort(dist2center, index.return = T)$ix[1:100]]
          return(nearest100)
        }))%>%
        unnest(data) %>%
        dplyr::select(-c(left_window, right_window)) %>%
        mutate(geno_size = map_dbl(geno_blk,length))
    }
  }
  # Specify the x and baseline for the segment and chose true mQTLs from the current candidates of the current segment
  # input: seg_tib, geno_info, L
  # output: X, mqtl, Y0
  input_tidy = function(seg_tib, geno_info, L){
    Y0 = seg_tib$ori_methy_rate
    tt <- sample(1:10,size=1) ##### William modification here  -----
    X =  t(geno_info$geno[(((tt-1)*100+1):(tt*100)),])  ### WD change here ----- # t(geno_info$geno[as.character(seg_tib$geno_blk[[1]]),]) #t(geno_info$geno[as.character(seg_tib$geno_blk[[1]]),])
    # X = t(geno_info$geno[as.character(seg_tib$geno_blk[[1]]),]) #t(geno_info$geno[as.character(seg_tib$geno_blk[[1]]),])
    mqtl = sample(colnames(X), size = L, replace = F)
    return(list(Y0 = Y0,
                X = X,
                mqtl = mqtl))
  }



  # generate the genotype effect from mvn model
  # input: outcome from input_tidy
  # output:
  # XB: X%*%B,
  # b_vec # a list indicating the b_vector of each mQTL
  # cov_list: oracle cov matrix of mvn generating b_vec

  effect_mvn = function(input_obj,corr_type,
                        num_block = 2, off_diag_corr = 1,
                        rho = 0.99, v_random, pve){
    mqtl = as.character(input_obj$mqtl)
    L = length(mqtl)
    X = input_obj$X
    J = dim(X)[2]
    R = length(input_obj$Y0)
    v_effect = (v_random/(1-pve*L))*pve
    # generate b_vec
    if(corr_type == 1){
      corr = block_corr_generate(R = R,
                                 num_block = num_block,
                                 off_diag_corr = off_diag_corr)
    }else if(corr_type == 2) {
      aver_block_start = ((1:R)-1)*84+1 #### ???? ----
      aver_block_start_mat = matrix(rep(aver_block_start, R), ncol = R)
      dist_mat = abs(t(aver_block_start_mat)-aver_block_start_mat)
      corr = rho^dist_mat
    }

    cov = block_cov_generate(corr = corr, v = v_effect)
    cov_list = list()
    cov_list[["ori_cov"]] = cov
    cov_list[["dwt_cov"]] = covDWT_from_covY(cov)
    b_vec_list = NULL
    for(i in 1:L){
      b_vec_list[[mqtl[i]]] = dae::rmvnorm(mean = rep(0,R),V = cov)
    }

    # calculate XB
    B = matrix(0,J,R)
    rownames(B) = colnames(X)
    for(i in 1:L){
      cur_mqtl = mqtl[i]
      B[cur_mqtl,] = b_vec_list[[cur_mqtl]]
    }
    XB = X %*% B
    return(list(XB = XB,
                b_vec_list = b_vec_list,
                cov = cov_list))
  }

  # generate the genotype effect from nig model
  # input: outcome from input_tidy
  # output:
  # XB: X%*%B,
  # b_vec # a list indicating the b_vector of each mQTL
  # cov_list: empirical cov matrix of mvn generating b_vec

  effect_nig = function(input_obj,tau, #para decay wavelet coefficient
                        alpha, #decay coefficient
                        eta, gamma, #transition
                        v_random,
                        pve){

    mqtl = as.character(input_obj$mqtl)
    L = length(mqtl)
    X = input_obj$X
    J = dim(X)[2]
    R = length(input_obj$Y0)
    max_depth = log(R,2)
    v_effect = (v_random/(1-pve*L))*pve
    # generate b_vec
    b_vec_list = list()
    dwt_b_vec_list = list()
    for(i in 1:L){
      twav = wd(rep(0, R))
      dwt_coef = NIG_MG_sim(tau = tau, #para decay wavelet coefficient
                            alpha = alpha, #decay coefficient
                            eta = eta, gamma = gamma, #transition
                            sigma = v_effect,     # variance
                            max_depth = max_depth)$coef
      twav$D = c(0, dwt_coef)
      ori_coef = wr(twav)
      b_vec_list[[mqtl[i]]] = ori_coef
      dwt_b_vec_list[[mqtl[i]]] = dwt_coef
    }

    # calculate XB
    B = matrix(0,J,R)
    rownames(B) = colnames(X)
    for(i in 1:L){
      cur_mqtl = mqtl[i]
      B[cur_mqtl,] = b_vec_list[[cur_mqtl]]
    }
    XB = X %*% B

    # calc empirical covariance matrix
    emp_mat = list.rbind(lapply(1:500,  function(i){
      twav = wd(rep(0, R))
      dwt_coef = NIG_MG_sim(tau = tau, #para decay wavelet coefficient
                            alpha = alpha, #decay coefficient
                            eta = eta, gamma = gamma, #transition
                            sigma = v_effect,     # variance
                            max_depth = max_depth)$coef
      twav$D = c(0, dwt_coef)
      wr(twav)
    }))
    cov = cov(emp_mat)
    cov_list = list()
    cov_list[["ori_cov"]] = cov
    cov_list[["dwt_cov"]] = covDWT_from_covY(cov)

    return(list(XB = XB,
                b_vec_list = b_vec_list,
                cov = cov_list))
  }

  # generate the genotype effect from mvn model
  # input: outcome from input_tidy
  # output:
  # XB: X%*%B,
  # b_vec # a list indicating the b_vector of each mQTL
  # emp_pi0: oracle cov matrix of mvn generating b_vec
  # ? ash_obj output?
  effect_ash = function(input_obj, v_random, pve,
                        mode, pi0 = NA){
    mqtl = as.character(input_obj$mqtl)
    L = length(mqtl)
    X = input_obj$X
    J = dim(X)[2]
    R = length(input_obj$Y0)
    v_effect = (v_random/(1-pve*L))*pve
    # generate b_vec
    ash_obj_list = list()
    for(i in 1:L){
      if(mode == "vanilla"){
        ash_obj_cur = simu_IBSS_ash_vanilla(lev_res = log(R,2),pi0 = pi0)
      }else if(mode == "per_level"){
        ash_obj_cur = simu_IBSS_per_level(lev_res = log(R,2), pi0 = pi0)
      }
      ash_obj_cur[1:2] = lapply(ash_obj_cur[1:2], function(x){
        rho = v_effect/var(x)
        x = x * sqrt(rho)
        x
      })
      ash_obj_list[[mqtl[i]]] = ash_obj_cur
    }

    b_vec_list = map(ash_obj_list,"sim_func")
    emp_pi0_list = map(ash_obj_list,"emp_pi0")

    # calculate XB
    B = matrix(0,J,R)
    rownames(B) = colnames(X)
    for(i in 1:L){
      cur_mqtl = mqtl[i]
      B[cur_mqtl,] = b_vec_list[[cur_mqtl]]
    }
    XB = X %*% B
    return(list(XB = XB,
                b_vec_list = b_vec_list,
                emp_pi0 = emp_pi0_list))
  }

  # random variance generation
  # output: E_{N*R}
  random_variance = function(n_samp, R, v_random){
    list.cbind(lapply(1:R, function(i) {
      rnorm(n = n_samp,mean = 0,sd = sqrt(v_random))}))
  }

  block_corr_generate = function(R = 64,# # sites
                                 num_block = 2,# #islands within the region
                                 off_diag_corr = 0.8 # correlation within the island
                                 # v = 0.001, # residual variance(before logit transformation)
                                 # pve = 0.01, # heritability par
                                 # pi_0_type = "beta"
  ){
    corr_b = matrix(0,R,R)
    region_mat = matrix(off_diag_corr,R/num_block,R/num_block)
    for(i in 1:num_block){
      corr_b[seq(((i-1)*(R/num_block)+1),i*(R/num_block)), seq(((i-1)*(R/num_block)+1),i*(R/num_block))] = region_mat
    }

    diag(corr_b) = 1
    return(corr_b)
  }

  block_cov_generate = function(corr, v){
    R = dim(corr)[1]
    cov = diag(sqrt(v),R) %*% corr %*% diag(sqrt(v),R)
    return(cov)
  }

  pair_SLR = function(geno, methy){
    p = dim(geno)[2]
    lm_res = list.rbind(lapply(1:p, function(i) {t(apply(methy, MARGIN = 2, FUN = function(y){
      summary(lm(y~geno[,i]))$coefficient[2,]
    }))}))
    rownames(lm_res) = paste(str_extract(colnames(methy), "\\d+"), rep(str_extract(colnames(geno),"\\d+"), each = dim(methy)[2]),  sep = "-")
    bhat_mat = matrix(lm_res[,1], byrow = T, nrow = dim(geno)[2])
    shat_mat = matrix(lm_res[,2], byrow = T, nrow = dim(geno)[2])
    p_mat = matrix(lm_res[,4], byrow = T, nrow = dim(geno)[2])
    # rownames(bhat_mat) = rownames(shat_mat) = colnames(geno)
    # colnames(bhat_mat) = colnames(shat_mat) = colnames(methy)
    #
    res = list(bhat = bhat_mat,
               sbhat = shat_mat,
               p_mat = p_mat)
    return(res)
  }

  # cov_oracle_transform function ----
  # DWT oracle cov structure from cov(Y)

  covDWT_from_covY = function(cov_Y,
                              filter_number = 1,
                              family = "DaubExPhase"){
    n = ncol(cov_Y)
    Mat_W = GenW(n = n, filter.number = filter_number, family = family)
    cov_Yf = t(Mat_W) %*% cov_Y %*% (Mat_W)
    cov_Yd = cov_Yf
    cov_Yd[,2:n] = cov_Yf[,n:2]
    cov_Yd[2:n,] = cov_Yd[n:2,]

    prior <- cov_Yd
    if(!isSymmetric(prior)){ prior=prior+t(prior)/2}
    return(prior)
  }

  covY_from_covDWT = function(cov_dwt,
                              filter_number = 1,
                              family = "DaubExPhase"){

    n = ncol(cov_dwt)
    Mat_W = GenW(n = n, filter.number = filter_number, family = family)
    cov_Yf = cov_dwt
    cov_Yd = cov_Yf
    cov_Yd[,2:n] = cov_Yf[,n:2]
    cov_Yd[2:n,] = cov_Yd[n:2,]

    cov_Y = Mat_W %*% cov_Yd %*% t(Mat_W)

    prior <- cov_Y
    if(!isSymmetric(prior)){ prior=prior+t(prior)/2}
    return(prior)
  }



  ############################################################################# ----
  # Main running start here, above are all functions ----
  blk_size = 2^log2_reg_leng
  # read in profile data  ----

  # methy_profile = methy_profile_tidy(profile_data = methy_profile_path,
  #                                    t = 1:4000,
  #                                    map_file = methy_map_path,
  #                                    blk_size = blk_size,
  #                                    sep_method = "even")
  # saveRDS(methy_profile, file = "~/../../Volumes/Yuqi_Backup/Projects/Research_data/neuro-mQTL/OmicsSIMLA/generated_methy_segment_profile.rds")

  methy_profile = readRDS("/home/wdenault/fsusi_simu/sim/Yuqi_data/generated_methy_segment_profile.rds")
  # set.seed(286)

  ## get the parameter combination ----
  # log2_reg_leng = log(dim(methy_profile %>% filter(seg_id == 1))[1],2)
  # scenario =  paste("log2_reg_leng",log2_reg_leng,
  #                   "simulate","simulate_mvn",
  #                   "pve", pve,
  #                   "L",L,
  #                   "add_profile_baseline", add_profile_baseline,
  #                   "corr_type", corr_type,
  #                   "num_block", num_block,
  #                   "off_diag_corr", off_diag_corr,
  #                   "rho",rho,
  #                   sep = "_")

  # filter to get current segment
  # geno_ann = readRDS(paste(genotype_file_dir, "/geno_ann.rds", sep = ""))
  # seg_tib = chosen_seg_and_find_geno(methy_profile = methy_profile,
  #                                    seg_id_cur = seg_id_cur,
  #                                    geno_ann = geno_ann,
  #                                    mode = "nearest_100"
  # )
  # saveRDS(seg_tib, file = "~/../../Volumes/Yuqi_Backup/Projects/Research_data/neuro-mQTL/OmicsSIMLA/seg_tib_MWE.rds")

  seg_tib = readRDS("/home/wdenault/fsusi_simu/sim/Yuqi_data/seg_tib_MWE.rds")
  # readin genotype data
  # geno_range = as_tibble(read.table(paste(genotype_file_dir,"/geno_file_range.txt", sep = "")))
  # geno = NULL
  # geno_id = as.character(seg_tib$geno_blk[[1]])
  # for(i in 1:10){
  #   if((min(geno_id) >= geno_range[i,2] & min(geno_id) <= geno_range[i,3])|
  #      (max(geno_id) >= geno_range[i,2] & max(geno_id) <= geno_range[i,3])){
  #     geno_cur = readRDS(paste(genotype_file_dir, "/genotype_", i, ".rds", sep = ""))
  #     geno = rbind(geno, geno_cur)
  #   }
  # }
  # # readin
  # geno_info = list(geno = geno, geno_ann = geno_ann)
  # saveRDS(geno_info, file = "~/../../Volumes/Yuqi_Backup/Projects/Research_data/neuro-mQTL/OmicsSIMLA/geno_list_MWE.rds")
  geno_info = readRDS("/home/wdenault/fsusi_simu/sim/Yuqi_data/geno_list_MWE.rds")
  # chose blks and snps and create links between them ----
  # if(corr_type_fun == 3){ pve = pve/L*10}
  L <-  sample (1:20,size=1)
  data_list = data_generation(seg_tib = seg_tib,
                              geno_info = geno_info,
                              scenario = "mvn",
                              v_random = v_random,
                              pve = pve/L,
                              L = L,
                              add_profile_baseline = add_profile_baseline,
                              corr_type = corr_type,
                              num_block = num_block,
                              off_diag_corr = off_diag_corr,
                              rho = rho
  )

  data_list[["seg_id"]] = seg_id_cur


  X = data_list$X[1:500,]

  if(length(which(apply(X,2,var)==0)>0)){
    X <- X[ , -which(apply(X,2,var)==0) ]
  }

  #hist(cor(X))
  #image(cor(X))
  # cor( X[, true_mqtl])

  Y = data_list$Y[1:500,]
  ## num of true effect
  true_mqtl = sapply(data_list$mqtl, function(x) which(x == colnames(X)))
  # assume the there is L=10 true effect


  cal_purity <- function(l_cs,X){
    tt <- c()
    for (k in 1:length(l_cs)){
      if(length(l_cs[[k]])==1 ){
        tt <- c( tt,1)
      }else{

        upper_diag <- X[,l_cs[[k]]][row(X[,l_cs[[k]]]) == (col(X[,l_cs[[k]]]) + 1)]# upper diga
        tt <- c( tt, mean(upper_diag))
      }

    }
    return(mean(tt))
  }

  res = susiF(Y  = Y, X = X, L =20, L_start=11 ,nullweight=10, cov_lev = 0.95 , cal_obj =FALSE,  maxit=10)
  res_tibble = tibble(n_cs = length(res$cs), # number of CS
                      size_cs= mean(lengths(res$cs)),
                      n_effect = length(which(true_mqtl%in% do.call(c, res$cs))), #number of effect foun
                      n_false_effect = Reduce("+",sapply(1:length(res$cs), function(k) ifelse( length(which(true_mqtl%in%res$cs[[k]] ))==0, 1,0))),# number of CS without any effect
                      Number_effect = length(true_mqtl),
                      mean_purity   = cal_purity(res$cs, X),
                      prior = "mixnorm") %>%
    mutate(power = n_effect/Number_effect,
           sd_power = sqrt(power*(1-power)),
           size_cs=size_cs,
           mean_purity=mean_purity,
           t1 = n_false_effect/n_cs, #### Change william here  ----
           sd_t1 = sqrt(t1*(1-t1)))
  res_out[[i]] <- res_tibble

  #n_cs size_cs n_effect n_false_effect Number_effect mean_purity prior   power sd_power    t1 sd_t1
  #tt <- do.call(rbind,res_out)

  #print( apply(tt[,-which(colnames(tt)=="prior")],2,mean))
  save(res_out, file ="/home/wdenault/fsusi_simu/sim/simu_script_Yuqi/res_out_005_ps.RData")
}





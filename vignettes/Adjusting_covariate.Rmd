---
title: "Accounting for covariate in functional fine-mapping"
author: "William R.P. Denault"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Adjusting_covariate}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Adjustement for functional fine-mapping

In order to reduce the number of false positives in fine-mapping analysis, it is often 
important to account for potential counfounders. As most of the tools in the SuSiE suite
don't account for confounders while performing fine-mapping, it is important to  account for potential counfounders prior to the analysis. Similar problem arise with FSuSiE. While it is
relatively straightforward to adjust univariate phenotypes. It is more complicated to adjust
curves for confounding. Thus we implemented a user freindly function that performs this preprocessing step.



```{r}
knitr::opts_chunk$set(
	echo = TRUE,
	message = FALSE,
	warning = FALSE
)
library(susiF.alpha)
library(susieR)
library(wavethresh)
set.seed(1)
data(N3finemapping)
attach(N3finemapping)

rsnr <- 0.5 #expected root signal noise ratio

pos1 <- 250   #Position of the causal covariate for effect 1
pos2 <- 750   #Position of the causal covariate for effect 1
lev_res <- 7#length of the molecular phenotype (2^lev_res)
f1 <-  simu_IBSS_per_level(lev_res )$sim_func#first effect
f2 <- simu_IBSS_per_level(lev_res )$sim_func #second effect

f_1cov  <- simu_IBSS_per_level(lev_res )$sim_func #effect cov 1
f_2cov  <- simu_IBSS_per_level(lev_res )$sim_func #effect cov 2
f_3cov  <- simu_IBSS_per_level(lev_res )$sim_func #effect cov 3

plot( f1, type ="l", ylab="effect", col="blue")
abline(a=0,b=0)
lines(f2, type="l", col="green")
legend(x=100,
       y=3,
       lty = rep(1,3),
      legend= c("effect 1", "effect 2" ),
       col=c("black","blue","yellow"))
```




```{r}

noisy.data  <- list()
Geno <- N3finemapping$X

Cov <- matrix(rnorm(n=nrow(Geno)*3), ncol=3)

for ( i in 1:nrow(X))
{
  f1_obs <- f1
  f2_obs <- f2
  noise <- rnorm(length(f1), sd=  (1/  rsnr ) * var(f1))
  noisy.data [[i]] <-  Geno [i,pos1]*f1_obs +Geno [i,pos2]*f2_obs + Cov [i,1]*f1_cov + Cov  [i,2]*f2_cov + Cov  [i,3]*f3_obs +noise

}
noisy.data <- do.call(rbind, noisy.data)

Y <- noisy.data

```


We use the function \textit{adjust_FM_covariate} to regress out the effect of the covariate (in the matrix Cov). The function output an object that contains 
* the adjusted curves
* the fitted effect (covariate)
* the corresponding position

NB: If you input matrix Y has a number of column that is not a power of 2. Then adjust_FM_covariate will remap the corresponding curves to a grid with $2^K$ points.  The adjusted curves and the fitted effect matrices 





doesn't account for potential counfounder while performing fine-mapping. T

covariate 
In many  cases it is important adjust for covariate 
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots





You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

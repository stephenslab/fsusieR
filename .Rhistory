lfsr_curve    = lfsr_curve,
outing_grid   = outing_grid,
filter.number = filter.number,
family        = family,
TI            = TI,
HMM           = HMM
)
library(susiF.alpha)
library(susiF.alpha)
library(ashr)
library(wavethresh)
set.seed(1)
#Example using curves simulated under the Mixture normal per scale prior
N=25
sd_noise <- 0.51#Number of individuals
P <- 10     #Number of covariates/SNP
pos1 <- 1   #Position of the causal covariate for effect 1
pos2 <- 5   #Position of the causal covariate for effect 2
lev_res <-7#length of the molecular phenotype (2^lev_res)
f1 <-  rep(0, 2^lev_res)
f1[ 20:25] <-2
f1[ 50:55] <-1
f1[ 20:25] <-2
f1 <-  0*simu_IBSS_per_level(lev_res )$sim_func
f1[60:length(f1)] <-0
f1[ 70] <- -1
#first effect)
f2 <-  0.1*DJ.EX(128)$blocks
plot( f1, type ="l", ylab="effect", col="blue")
lines(f2, col="red")
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
#f2 <-f1
G = matrix(sample(c(0, 1,2), size=N*P, replace=TRUE), nrow=N, ncol=P) #Genotype
X <-G
for ( i in 1:N)
{
noise <- rnorm(length(f1), sd=  sd_noise)
noisy.data [[i]] <-   beta1*G[i,pos1]*f1 + beta1*G[i,pos2]*f2  + noise
}
noisy.data <- do.call(rbind, noisy.data)
Y <- noisy.data
Y[,10:20]<- 0*Y[,10:20]
out <- susiF(Y,X,L=2 , prior = 'mixture_normal_per_scale'  )
out2 <- susiF(Y,X,L=2 , prior = 'mixture_normal_per_scale', post_processing = "HMM"  )
devtools::load_all(".")
L=2
post_processing = "HMM"
verbose = TRUE
maxit = 100
tol = 1e-3
cov_lev = 0.95
min.purity=0.5
filter.cs =TRUE
init_pi0_w= 1
lfsr_curve=0.05
nullweight= 10
control_mixsqp =  list(verbose=FALSE,
eps = 1e-6,
numiter.em = 4
)
thresh_lowcount=0
cal_obj=FALSE
L_start = 3
quantile_trans=FALSE
greedy =TRUE
backfit =TRUE
gridmult= sqrt(2)
max_scale=10
max_SNP_EM=1000
max_step_EM=1
cor_small=FALSE
filter.number = 10
family = "DaubLeAsymm"
filter.number = 10
if(max_SNP_EM<10){
stop("Argument max_SNP_EM has to be larger than 10")
}
if(post_processing=="TI"){
TI  <- TRUE
HMM <- FALSE
}
if(post_processing=="HMM"){
TI  <- FALSE
HMM <- TRUE
}
if(post_processing=="none"){
TI  <- FALSE
HMM <- FALSE
}
####Cleaning input -----
pt <- proc.time()
if( prior %!in% c("normal", "mixture_normal", "mixture_normal_per_scale"))
{
stop("Error: provide valid prior input")
}
prior = 'mixture_normal_per_scale'
if(!cal_obj){
tol <-10^-3
}
if(L_start >L)
{
L_start <- L
}
if (is.null(pos))
{
pos <- 1:dim(Y)[2]
}
pos <- 1:dim(Y)[2]
#reshaping of the data
if ( !(length(pos)==dim(Y)[2])) #miss matching positions and number of observations
{
stop("Error: number of position provided different from the number of column of Y")
}
map_data <- remap_data(Y=Y,
pos=pos,
verbose=verbose,
max_scale=max_scale)
outing_grid <- map_data$outing_grid
Y           <- map_data$Y
rm( map_data)
# centering and scaling covariate
tidx <- which(apply(X,2,var)==0)
if( length(tidx)>0){
warning(paste("Some of the columns of X are constants, we removed" ,length(tidx), "columns"))
X <- X[,-tidx]
}
X <- colScale(X)
# centering input
Y <- colScale(Y, scale=FALSE)
W <- DWT2(Y,
filter.number = filter.number,
family        = family)
Y_f      <-  cbind( W$D,W$C)
if(verbose){
print("Starting initialization")
}
if(verbose){
print("Data transform")
}
indx_lst <-  gen_wavelet_indx(log2(length( outing_grid)))
lowc_wc <-   which_lowcount(Y_f,thresh_lowcount)
if(verbose){
print( paste("Discarding ", length(lowc_wc), "wavelet coefficients out of ", ncol(Y_f)))
}
if(length(lowc_wc)> (ncol(Y_f )-3)){
stop("almost all the wavelet coefficients are null/low variance, consider using univariate fine mapping")
}
if(quantile_trans)# important to do it after testing for lowcount
{
W$C <- Quantile_transform(W$C )
W$D <- apply( W$D,2,  Quantile_transform )
Y_f      <-  cbind( W$D,W$C)
}
v1       <-  rep(1, dim(X)[1])### used in fit_lm to add a column of 1 in the design matrix
update_D <- W
if(verbose){
print("Data transform done")
}
### Definition of some dynamic parameters ------
if(verbose){
print("Initializing prior")
}
update_Y    <- cbind( W$D,W$C) #Using a column like phenotype, temporary matrix that will be regularly updated
temp        <- init_prior(Y              = update_Y,
X              = X,
prior          = prior ,
v1             = v1,
indx_lst       = indx_lst,
lowc_wc        = lowc_wc,
control_mixsqp = control_mixsqp,
nullweight     = nullweight,
gridmult       = gridmult,
max_SNP_EM     = max_SNP_EM,
max_step_EM    = max_step_EM,
cor_small      = cor_small)
G_prior     <- temp$G_prior
tt          <- temp$tt
#Recycled for the first step of the while loop
susiF.obj   <-  init_susiF_obj(L_max=L,
G_prior=G_prior,
Y=Y,
X=X,
L_start=L_start,
greedy=greedy,
backfit=backfit)
if(verbose){
print("Initialization done")
}
susiF.obj     <- susiF.workhorse(susiF.obj      = susiF.obj,
W              = W,
X              = X,
tol            = tol,
low_wc         = low_wc,
init_pi0_w     = init_pi0_w ,
control_mixsqp = control_mixsqp ,
indx_lst       = indx_lst,
lowc_wc        = lowc_wc,
nullweight     = nullweight,
cal_obj        = cal_obj,
verbose        = verbose,
cov_lev        = cov_lev,
min.purity     = min.purity,
maxit          = maxit,
tt             = tt,
max_SNP_EM     = max_SNP_EM,
max_step_EM    = max_step_EM,
cor_small      = cor_small )
susiF.obj <- out_prep(susiF.obj     = susiF.obj,
Y             = Y,
X             = X,
indx_lst      = indx_lst,
filter.cs     = filter.cs,
lfsr_curve    = lfsr_curve,
outing_grid   = outing_grid,
filter.number = filter.number,
family        = family,
TI            = TI,
HMM           = HMM
)
idx <- do.call( c, lapply( 1:length(susiF.obj$cs),
function(l){
tp_id <-  which.max(susiF.obj$alpha[[l]])
}
)
)
idx
temp_Y <- Y
X <- X[complete.cases(Y),]
Y <- Y[complete.cases(Y),]
sub_X <- X[, idx]
fitted_trend  <- list()
fitted_lfsr   <- list()
tt <- lapply( 1: ncol(Y),
function(j)
summary(lm(Y[,j]~sub_X))$coefficients[-1,c(1,2)])
fitted_trend <- list()
fitted_lfsr   <- list()
shift <-0
for ( l in 1: length(idx)){
#print( l)
if(dim(table (sub_X[,l]) ) ==1){
fitted_lfsr [[l]] <- rep(1 , ncol(Y))
fitted_trend[[l]] <- rep(0 , ncol(Y))
shift <-shift +1
}else{
est  <- do.call(c, lapply( 1: length(tt) ,function (j) tt[[j]][(l-shift ),1]))
sds  <- do.call(c, lapply( 1: length(tt) ,function (j) tt[[j]][(l-shift ),2]))
s = fit_hmm(x=est ,sd=sds ,halfK=20 )
fitted_lfsr [[l]] <- s$lfsr
fitted_trend[[l]] <- s$x_post
}
}
fitted_trend <- lapply(1:length(idx), function(l)
fitted_trend[[l]]/susiF.obj$csd_X[idx[l]]
)
susiF.obj$fitted_func <- fitted_trend
susiF.obj$lfsr_func   <- fitted_lfsr
mean_Y          <- attr(Y, "scaled:center")
mean_Y
Y
attr(Y, "scaled:center")
if(max_SNP_EM<10){
stop("Argument max_SNP_EM has to be larger than 10")
}
if(post_processing=="TI"){
TI  <- TRUE
HMM <- FALSE
}
if(post_processing=="HMM"){
TI  <- FALSE
HMM <- TRUE
}
if(post_processing=="none"){
TI  <- FALSE
HMM <- FALSE
}
####Cleaning input -----
pt <- proc.time()
if( prior %!in% c("normal", "mixture_normal", "mixture_normal_per_scale"))
{
stop("Error: provide valid prior input")
}
if(!cal_obj){
tol <-10^-3
}
if(L_start >L)
{
L_start <- L
}
## Input error messages
if (is.null(pos))
{
pos <- 1:dim(Y)[2]
}
#reshaping of the data
if ( !(length(pos)==dim(Y)[2])) #miss matching positions and number of observations
{
stop("Error: number of position provided different from the number of column of Y")
}
map_data <- remap_data(Y=Y,
pos=pos,
verbose=verbose,
max_scale=max_scale)
outing_grid <- map_data$outing_grid
Y           <- map_data$Y
rm( map_data)
# centering and scaling covariate
tidx <- which(apply(X,2,var)==0)
if( length(tidx)>0){
warning(paste("Some of the columns of X are constants, we removed" ,length(tidx), "columns"))
X <- X[,-tidx]
}
X <- colScale(X)
# centering input
Y <- colScale(Y, scale=FALSE)
W <- DWT2(Y,
filter.number = filter.number,
family        = family)
Y_f      <-  cbind( W$D,W$C)
if(verbose){
print("Starting initialization")
}
if(verbose){
print("Data transform")
}
#X <- matrix(X)
### Definition of some static parameters ---
indx_lst <-  gen_wavelet_indx(log2(length( outing_grid)))
#removing wc with variance 0 or below a certain level
lowc_wc <-   which_lowcount(Y_f,thresh_lowcount)
if(verbose){
print( paste("Discarding ", length(lowc_wc), "wavelet coefficients out of ", ncol(Y_f)))
}
if(length(lowc_wc)> (ncol(Y_f )-3)){
stop("almost all the wavelet coefficients are null/low variance, consider using univariate fine mapping")
}
if(quantile_trans)# important to do it after testing for lowcount
{
W$C <- Quantile_transform(W$C )
W$D <- apply( W$D,2,  Quantile_transform )
Y_f      <-  cbind( W$D,W$C)
}
v1       <-  rep(1, dim(X)[1])### used in fit_lm to add a column of 1 in the design matrix
# Wavelet transform of the inputs
update_D <- W
if(verbose){
print("Data transform done")
}
### Definition of some dynamic parameters ------
if(verbose){
print("Initializing prior")
}
update_Y    <- cbind( W$D,W$C) #Using a column like phenotype, temporary matrix that will be regularly updated
temp        <- init_prior(Y              = update_Y,
X              = X,
prior          = prior ,
v1             = v1,
indx_lst       = indx_lst,
lowc_wc        = lowc_wc,
control_mixsqp = control_mixsqp,
nullweight     = nullweight,
gridmult       = gridmult,
max_SNP_EM     = max_SNP_EM,
max_step_EM    = max_step_EM,
cor_small      = cor_small)
G_prior     <- temp$G_prior
tt          <- temp$tt
#Recycled for the first step of the while loop
susiF.obj   <-  init_susiF_obj(L_max=L,
G_prior=G_prior,
Y=Y,
X=X,
L_start=L_start,
greedy=greedy,
backfit=backfit)
if(verbose){
print("Initialization done")
}
# numerical value to check breaking condition of while
susiF.obj     <- susiF.workhorse(susiF.obj      = susiF.obj,
W              = W,
X              = X,
tol            = tol,
low_wc         = low_wc,
init_pi0_w     = init_pi0_w ,
control_mixsqp = control_mixsqp ,
indx_lst       = indx_lst,
lowc_wc        = lowc_wc,
nullweight     = nullweight,
cal_obj        = cal_obj,
verbose        = verbose,
cov_lev        = cov_lev,
min.purity     = min.purity,
maxit          = maxit,
tt             = tt,
max_SNP_EM     = max_SNP_EM,
max_step_EM    = max_step_EM,
cor_small      = cor_small )
#preparing output
attr(Y, "scaled:center")
caca <- Y[complete.cases(Y),]
attr( caca, "scaled:center")
complete.cases
library(susiF.alpha)
library(susiF.alpha)
library(ashr)
library(wavethresh)
set.seed(1)
#Example using curves simulated under the Mixture normal per scale prior
N=25
sd_noise <- 0.51#Number of individuals
P <- 10     #Number of covariates/SNP
pos1 <- 1   #Position of the causal covariate for effect 1
pos2 <- 5   #Position of the causal covariate for effect 2
lev_res <-7#length of the molecular phenotype (2^lev_res)
f1 <-  rep(0, 2^lev_res)
f1[ 20:25] <-2
f1[ 50:55] <-1
f1[ 20:25] <-2
f1 <-  0*simu_IBSS_per_level(lev_res )$sim_func
f1[60:length(f1)] <-0
f1[ 70] <- -1
#first effect)
f2 <-  0.1*DJ.EX(128)$blocks
plot( f1, type ="l", ylab="effect", col="blue")
lines(f2, col="red")
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
#f2 <-f1
G = matrix(sample(c(0, 1,2), size=N*P, replace=TRUE), nrow=N, ncol=P) #Genotype
X <-G
for ( i in 1:N)
{
noise <- rnorm(length(f1), sd=  sd_noise)
noisy.data [[i]] <-   beta1*G[i,pos1]*f1 + beta1*G[i,pos2]*f2  + noise
}
noisy.data <- do.call(rbind, noisy.data)
Y <- noisy.data
Y[,10:20]<- 0*Y[,10:20]
out <- susiF(Y,X,L=2 , prior = 'mixture_normal_per_scale'  )
out2 <- susiF(Y,X,L=2 , prior = 'mixture_normal_per_scale', post_processing = "HMM"  )
plot( out2$fitted_func[[1]])
lines(out2$lfsr_func[[1]])
lines(f2)
plot( out2$fitted_func[[1]])
lines(out2$lfsr_func[[1]])
plot( out2$fitted_func[[2]])
lines(out2$lfsr_func[[2]])
plot( f1, type ="l", ylab="effect", col="blue")
plot( f1, type ="l", ylab="effect", col="blue", ylim= c(-1.2,1.2))
points( out2$fitted_func[[2]])
lines(out2$lfsr_func[[2]])
plot( f2, type ="l", ylab="effect", col="red" )
plot( out2$fitted_func[[1]])
plot( f2, type ="l", ylab="effect", col="red" )
points( out2$fitted_func[[1]])
lines(out2$lfsr_func[[1]])
library(susiF.alpha)
library(susiF.alpha)
library(susiF.alpha)
library(ashr)
library(wavethresh)
set.seed(1)
#Example using curves simulated under the Mixture normal per scale prior
N=25
sd_noise <- 0.51#Number of individuals
P <- 10     #Number of covariates/SNP
pos1 <- 1   #Position of the causal covariate for effect 1
pos2 <- 5   #Position of the causal covariate for effect 2
lev_res <-7#length of the molecular phenotype (2^lev_res)
f1 <-  rep(0, 2^lev_res)
f1[ 20:25] <-2
f1[ 50:55] <-1
f1[ 20:25] <-2
f1 <-  0*simu_IBSS_per_level(lev_res )$sim_func
f1[60:length(f1)] <-0
f1[ 70] <- -1
#first effect)
f2 <-  0.1*DJ.EX(128)$blocks
plot( f1, type ="l", ylab="effect", col="blue")
lines(f2, col="red")
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
#f2 <-f1
G = matrix(sample(c(0, 1,2), size=N*P, replace=TRUE), nrow=N, ncol=P) #Genotype
X <-G
for ( i in 1:N)
{
noise <- rnorm(length(f1), sd=  sd_noise)
noisy.data [[i]] <-   beta1*G[i,pos1]*f1 + beta1*G[i,pos2]*f2  + noise
}
noisy.data <- do.call(rbind, noisy.data)
Y <- noisy.data
Y[,10:20]<- 0*Y[,10:20]
out <- susiF(Y,X,L=2 , prior = 'mixture_normal_per_scale'  )
out <- susiF(Y,X,L=2 , prior = 'mixture_normal_per_scale' , post_processing = "HMM" )
out2 <-out
plot( out2$fitted_func[[1]])
lines(out2$lfsr_func[[1]])
plot( out2$fitted_func[[2]])
lines(out2$lfsr_func[[2]])
plot( f1, type ="l", ylab="effect", col="blue")
plot( f2, type ="l", ylab="effect", col="blue")
poitns( out2$fitted_func[[1]])
points( out2$fitted_func[[1]])

temp$D <-   (alpha_col[[l]] *X[i,])%*%fitted_wc_col[[l]][,-dim(fitted_wc_col[[l]])[2]]
temp$C[length(temp$C)] <- (alpha_col[[l]] *X[i,]) %*%fitted_wc_col[[l]][,dim(fitted_wc_col[[l]])[2]]
ind_fitted_func[i,]  <-  ind_fitted_func[i,]+wr(temp)
}
}
#### Compute CS and PIP
pip <- list()
cs <- list()
for( l in 1:L)
{
temp        <- alpha_col[[l]]
temp_cumsum <- cumsum( temp[order(temp, decreasing =TRUE)])
max_indx_cs <- min(which( temp_cumsum >0.95))
cs[[l]]  <- order(temp, decreasing = TRUE)[1:max_indx_cs ]
pip[[l]] <- rep(1, dim(X)[2])-alpha_col[[l]]
}
pip <- 1-  apply( do.call(rbind,pip),2, prod)
out <- list( #fitted_baseline = fitted_baseline,
pip             = pip,
cs              = cs,
fitted_wc       = fitted_wc_col ,
fitted_func     = fitted_func,
ind_pred        = ind_fitted_func,
alpha           = alpha_col,
alpha_hist      = alpha_col_hist,
#elbohist        = elbohist,
outing_grid     = outing_grid,
est_pi0         = lapply(pi_prior_list, function(x) x[1])
)
return(out)
}
#Number of individuals
N = 50
#Number of covariates
P = 5
#root signal noise ratio
rsnr   <- 2
#Choosing which variable will have an effect
pos1 <- 1
pos2 <- 2
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
idx <- sample( size =3, 1:4)#sample at random the different function for basaline/effect
for ( i in 1:N)
{
test_func <- wavethresh::DJ.EX(n = 1024, rsnr = rsnr, noisy = TRUE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
noisy.data [[i]] <-  beta0*f0 +  beta1*G[i,pos1]*f1 + beta2*G[i,pos2]*f2
}
noisy.data <- do.call(rbind, noisy.data)
test_func <- wavethresh::DJ.EX(n = 1024,   noisy = FALSE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
plot(f0-0.1,
type="l",
main="Underlying function depending on the SNP",
ylim=c(3*min(f0,f1,f2),3*max(f0,f1,f2)),
ylab="y",
xlab="time"
)
lines(f1+0.1+f0, col="red")
lines(f2-0.2+f0, col="green")
lines(f1+f2+f0+0.3, col="blue")
legend(x = c(0),
y= 100,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
#Generating individual curve sample with noise, parameter rsnr in the loop below
plot( noisy.data[1,],
col= "black",
type ="l",
ylim=c(-150,150),
ylab="y",
xlab="time",
main="Observed noisy curves"
)
for ( i  in 2: N)
{
if( G[i, 1]==0  & G[i,2]==0)
{
my_col <- "black"
}
if( G[i, 1]>0  & G[i,2]==0)
{
my_col <- "red"
}
if( G[i, 1]==0  & G[i,2]>0)
{
my_col <- "green"
}
if( G[i, 1]>0  & G[i,2]>0)
{
my_col <- "blue"
}
lines( noisy.data[i,], col=   my_col)
}
legend(x = c(0),
y= -5,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
Y <- noisy.data
X <- G
out <-IBSS_per_level(Y=Y,X=X , verbose = FALSE)
out2 <-IBSS_ash_sl(Y=Y,X=X , verbose = FALSE)
out$pip
out$pip[order(out$pip)]
out$cs
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[2]], col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[1]],col="blue")
N = 50
#Number of covariates
P = 5
#root signal noise ratio
rsnr   <- 1
#Choosing which variable will have an effect
pos1 <- 1
pos2 <- 2
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
idx <- sample( size =3, 1:4)#sample at random the different function for basaline/effect
for ( i in 1:N)
{
test_func <- wavethresh::DJ.EX(n = 1024, rsnr = rsnr, noisy = TRUE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
noisy.data [[i]] <-  beta0*f0 +  beta1*G[i,pos1]*f1 + beta2*G[i,pos2]*f2
}
noisy.data <- do.call(rbind, noisy.data)
test_func <- wavethresh::DJ.EX(n = 1024,   noisy = FALSE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
plot(f0-0.1,
type="l",
main="Underlying function depending on the SNP",
ylim=c(3*min(f0,f1,f2),3*max(f0,f1,f2)),
ylab="y",
xlab="time"
)
lines(f1+0.1+f0, col="red")
lines(f2-0.2+f0, col="green")
lines(f1+f2+f0+0.3, col="blue")
legend(x = c(0),
y= 100,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
#Generating individual curve sample with noise, parameter rsnr in the loop below
plot( noisy.data[1,],
col= "black",
type ="l",
ylim=c(-150,150),
ylab="y",
xlab="time",
main="Observed noisy curves"
)
for ( i  in 2: N)
{
if( G[i, 1]==0  & G[i,2]==0)
{
my_col <- "black"
}
if( G[i, 1]>0  & G[i,2]==0)
{
my_col <- "red"
}
if( G[i, 1]==0  & G[i,2]>0)
{
my_col <- "green"
}
if( G[i, 1]>0  & G[i,2]>0)
{
my_col <- "blue"
}
lines( noisy.data[i,], col=   my_col)
}
legend(x = c(0),
y= -5,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
Y <- noisy.data
X <- G
out <-IBSS_per_level(Y=Y,X=X , verbose = FALSE)
out2 <-IBSS_ash_sl(Y=Y,X=X , verbose = FALSE)
out$pip
out$pip[order(out$pip)]
out$cs
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[2]], col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[1]],col="blue")
N = 50
#Number of covariates
P = 5
#root signal noise ratio
rsnr   <- 0.5
#Choosing which variable will have an effect
pos1 <- 1
pos2 <- 2
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
idx <- sample( size =3, 1:4)#sample at random the different function for basaline/effect
for ( i in 1:N)
{
test_func <- wavethresh::DJ.EX(n = 1024, rsnr = rsnr, noisy = TRUE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
noisy.data [[i]] <-  beta0*f0 +  beta1*G[i,pos1]*f1 + beta2*G[i,pos2]*f2
}
noisy.data <- do.call(rbind, noisy.data)
test_func <- wavethresh::DJ.EX(n = 1024,   noisy = FALSE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
plot(f0-0.1,
type="l",
main="Underlying function depending on the SNP",
ylim=c(3*min(f0,f1,f2),3*max(f0,f1,f2)),
ylab="y",
xlab="time"
)
lines(f1+0.1+f0, col="red")
lines(f2-0.2+f0, col="green")
lines(f1+f2+f0+0.3, col="blue")
legend(x = c(0),
y= 100,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
#Generating individual curve sample with noise, parameter rsnr in the loop below
plot( noisy.data[1,],
col= "black",
type ="l",
ylim=c(-150,150),
ylab="y",
xlab="time",
main="Observed noisy curves"
)
for ( i  in 2: N)
{
if( G[i, 1]==0  & G[i,2]==0)
{
my_col <- "black"
}
if( G[i, 1]>0  & G[i,2]==0)
{
my_col <- "red"
}
if( G[i, 1]==0  & G[i,2]>0)
{
my_col <- "green"
}
if( G[i, 1]>0  & G[i,2]>0)
{
my_col <- "blue"
}
lines( noisy.data[i,], col=   my_col)
}
legend(x = c(0),
y= -5,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
Y <- noisy.data
X <- G
out <-IBSS_per_level(Y=Y,X=X , verbose = FALSE)
out2 <-IBSS_ash_sl(Y=Y,X=X , verbose = FALSE)
out$pip
out$pip[order(out$pip)]
out$cs
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[2]], col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[1]],col="blue")
#Number of individuals
N = 50
#Number of covariates
P = 5
#root signal noise ratio
rsnr   <- 0.5
#Choosing which variable will have an effect
pos1 <- 1
pos2 <- 2
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
idx <- sample( size =3, 1:4)#sample at random the different function for basaline/effect
for ( i in 1:N)
{
test_func <- wavethresh::DJ.EX(n = 1024, rsnr = rsnr, noisy = TRUE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
noisy.data [[i]] <-  beta0*f0 +  beta1*G[i,pos1]*f1 + beta2*G[i,pos2]*f2
}
noisy.data <- do.call(rbind, noisy.data)
test_func <- wavethresh::DJ.EX(n = 1024,   noisy = FALSE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
plot(f0-0.1,
type="l",
main="Underlying function depending on the SNP",
ylim=c(3*min(f0,f1,f2),3*max(f0,f1,f2)),
ylab="y",
xlab="time"
)
lines(f1+0.1+f0, col="red")
lines(f2-0.2+f0, col="green")
lines(f1+f2+f0+0.3, col="blue")
legend(x = c(0),
y= 100,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
#Generating individual curve sample with noise, parameter rsnr in the loop below
plot( noisy.data[1,],
col= "black",
type ="l",
ylim=c(-150,150),
ylab="y",
xlab="time",
main="Observed noisy curves"
)
for ( i  in 2: N)
{
if( G[i, 1]==0  & G[i,2]==0)
{
my_col <- "black"
}
if( G[i, 1]>0  & G[i,2]==0)
{
my_col <- "red"
}
if( G[i, 1]==0  & G[i,2]>0)
{
my_col <- "green"
}
if( G[i, 1]>0  & G[i,2]>0)
{
my_col <- "blue"
}
lines( noisy.data[i,], col=   my_col)
}
legend(x = c(0),
y= -5,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
Y <- noisy.data
X <- G
out <-IBSS_per_level(Y=Y,X=X , verbose = FALSE)
out2 <-IBSS_ash_sl(Y=Y,X=X , verbose = FALSE)
out$pip
out$pip[order(out$pip)]
out$cs
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[2]], col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[1]],col="blue")
plot(f2,type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[1]],col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[2]], col="green")
plot(f1, type="l")
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[1]],col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out2$fitted_func[[2]], col="green")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[2]], col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[1]],col="blue")
out$pip
log(1-out$pip)
log(1-out2$pip)
r of covariates
P = 50
#root signal noise ratio
rsnr   <- 0.2
#Choosing which variable will have an effect
pos1 <- 1
pos2 <- 2
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
beta2       <- 1
noisy.data  <- list()
idx <- sample( size =3, 1:4)#sample at random the different function for basaline/effect
for ( i in 1:N)
{
test_func <- wavethresh::DJ.EX(n = 1024, rsnr = rsnr, noisy = TRUE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
noisy.data [[i]] <-  beta0*f0 +  beta1*G[i,pos1]*f1 + beta2*G[i,pos2]*f2
}
noisy.data <- do.call(rbind, noisy.data)
test_func <- wavethresh::DJ.EX(n = 1024,   noisy = FALSE )
f0        <- beta0*test_func[[idx[1]]] #Baseline
f1        <- test_func[[idx[2]]]
f2        <- test_func[[idx[3]]]
plot(f0-0.1,
type="l",
main="Underlying function depending on the SNP",
ylim=c(3*min(f0,f1,f2),3*max(f0,f1,f2)),
ylab="y",
xlab="time"
)
lines(f1+0.1+f0, col="red")
lines(f2-0.2+f0, col="green")
lines(f1+f2+f0+0.3, col="blue")
legend(x = c(0),
y= 100,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
#Generating individual curve sample with noise, parameter rsnr in the loop below
plot( noisy.data[1,],
col= "black",
type ="l",
ylim=c(-150,150),
ylab="y",
xlab="time",
main="Observed noisy curves"
)
for ( i  in 2: N)
{
if( G[i, 1]==0  & G[i,2]==0)
{
my_col <- "black"
}
if( G[i, 1]>0  & G[i,2]==0)
{
my_col <- "red"
}
if( G[i, 1]==0  & G[i,2]>0)
{
my_col <- "green"
}
if( G[i, 1]>0  & G[i,2]>0)
{
my_col <- "blue"
}
lines( noisy.data[i,], col=   my_col)
}
legend(x = c(0),
y= -5,
c("0,0", "1,0", "0,1","1,1"),
col= c("black", "red","green", "blue"),
lty = rep(1,4)
)
Y <- noisy.data
X <- G
out <-IBSS_per_level(Y=Y,X=X , verbose = FALSE)
out2 <-IBSS_ash_sl(Y=Y,X=X , verbose = FALSE)
out$pip
out$pip[order(out$pip)]
out$cs
plot(f2,type="l")
lines(out2$fitted_func[[2]], col="green")
lines(out$fitted_func[[2]], col="blue")
plot(f1, type="l")
lines(out2$fitted_func[[1]], col="green")
lines(out$fitted_func[[1]],col="blue")
log(1-out$pip)
log(1-out2$pip)

return(postmean(get_fitted_g(m),data))
}
return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
t_m_post )))
}
out <- lapply( 1:(dim(Bhat)[1]),
FUN= t_col_post)
return(t(do.call(cbind, out)))
}
#'@title Compute posterior standard deviation under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior standard deviation
#'@export
post_mat_sd.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
t_col_post <- function(t){
m <- G_prior [[1]]
data <-  set_data(Bhat[t, ] ,Shat[t, ] )
return(postsd(get_fitted_g(m),data))
}
out <- lapply(1:(dim(Bhat)[1] ),t_col_post )
return(t(do.call(cbind, out)))
}
#'@title Compute posterior standard deviation under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return pxJ matrix of posterior standard deviation
#'@export
post_mat_sd.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
t_col_post <- function(t ){
t_sd_post <- function(s){
m <- G_prior [[ s]]
data <-  set_data(Bhat[t,indx_lst[[s]] ],
Shat[t, indx_lst[[s]] ]
)
return(postsd(get_fitted_g(m),data))
}
return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
t_sd_post )))
}
out <- lapply( 1:(dim(Bhat)[1]),
FUN= t_col_post)
return(t(do.call(cbind, out)))
}
#'@title Compute likelihood matrix for mixsqp under mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return See L argument mixsqp package mixsqp function
#'@export
L_mixsq.mixture_normal <- function(G_prior,Bhat, Shat, indx_lst)
{
m     <-  (G_prior[[1]])
sdmat <- sqrt(outer(c(Shat ^2),get_sd_G_prior(G_prior)^2,"+"))
L     <- (
dnorm(
outer(
c(Bhat),
rep(0,length(get_sd_G_prior(G_prior))),
FUN="-"
)/sdmat,
log=TRUE
) -log(sdmat )
)
class(L) <- "lik_mixture_normal"
return(L)
}
#'@title Compute likelihood matrix for mixsqp under mixture  normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return List of L matrix (see L argument mixsqp package mixsqp function)
#'@export
L_mixsq.mixture_normal_per_scale <- function(G_prior,Bhat, Shat, indx_lst)
{
L  <- lapply(1:length(indx_lst  ) , function(s) cal_L_mixsq_s_per_scale (G_prior,s, Bhat, Shat, indx_lst))
class(L) <- "lik_mixture_normal_per_scale"
return(L)
}
#'@title Sub routine to compute likelihood matrix at scale s for mixsqp under mixture normal per scale prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@param s scale where the likelihood matrix should be computed
#'@param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'@param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return L see L argument mixsqp package mixsqp function
#'@export
cal_L_mixsq_s_per_scale <- function(G_prior,s, Bhat, Shat ,indx_lst)
{
m <-  (G_prior[[s]])
sdmat <-sqrt(outer(c(Shat[,indx_lst[[s]]]^2),get_sd_G_prior(G_prior)[[s]]^2,"+"))
L = (dnorm(outer(c(Bhat[,indx_lst[[s]]]),m$fitted_g$mean,FUN="-")/sdmat,log=TRUE) -log(sdmat ))
return(L)
}
#'@title Compute M step in the wieghted ash problem for normal mixture prior
#'@description
#'@param L output of L_mixsqp function
#'@param zeta assignment probabilities for each covariate
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return a vector of proportion (class pi_mixture_normal)
#'@export
m_step.lik_mixture_normal <- function(L, zeta, indx_lst)
{
w <- rep( zeta,sum(lengths(indx_lst))) #setting the weight to fit the weighted ash problem
tlength <- dim(L)[2]-1
mixsqp_out <- mixsqp(L,
w,
log=TRUE,
x0 = c(1, rep(1e-30,  tlength )),# put starting point close to sparse solution
control = list(
eps = 1e-6,
numiter.em = 20,
verbose=FALSE
)
)
out <- mixsqp_out$x
class( out ) <-  "pi_mixture_normal"
return(out)
}
#'@title Compute M step in the weighted ash problem for normal mixture prior
#'@description
#'@param L output of L_mixsqp function
#'@param zeta assignment probabilities for each covariate
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return a list if vector of proportion (class pi_mixture_normal_per_scale)
#'@export
m_step.lik_mixture_normal_per_scale <- function(L, zeta, indx_lst)
{
#setting the weight to fit the wieghted ash problem
out <- lapply(1:length(indx_lst) ,
function(s) scale_m_step(L,s,zeta,indx_lst)
)
class( out ) <-  "pi_mixture_normal_per_scale"
return(out)
}
#'@title Subroutine to compute M step in the weighted ash problem for normal mixture prior per scale at a given scale s
#'@description
#'@param L output of the L_mixsqp.mixture_normal_per_scale function
#'@param s scale
#'@param zeta assignment probabilities for each covariate
#'@param indx_list list generated by gen_wavelet_indx for the given level of resolution, used only with class \class{mixture_normal_per_scale}
#'@return a vector of proportion for the scale s
scale_m_step <- function(L,s,zeta, indx_lst)
{
w <- rep(zeta,length(indx_lst[[s]] ))
tlength <- dim(L[[s]])[2]-1
mixsqp_out <- mixsqp( L[[s]] ,
w,
x0 = c(1, rep(1e-30,  tlength )),
log=TRUE ,
control = list(
eps = 1e-6,
numiter.em = 20,
verbose=FALSE
)
)
out <- mixsqp_out$x
return( out)
}
#'@title Compute assignment probabilities from log Bayes factors
#'@description
#'@param lBF vector of log Bayes factors
cal_zeta <- function(lBF)
{
out <- exp(lBF - max(lBF ) ) /sum( exp(lBF - max(lBF ) ))
return(out)
}
#'@title Compute likelihood for the weighted ash problem
#'@description
#'@param lBF vector of log Bayes factors
#'@param zeta assignement probabilities
#'@return Likelihood value
#'@export
cal_lik <- function(lBF,zeta)
{
out <- sum( zeta*exp(lBF - max(lBF ) ))
return(out)
}
#'@title Update mixture proportion for mixture normal prior
#'@description
#'@param G a prior of class "mixture_normal"
#'@param tpi a vector of proportion of class"pi_mixture_normal"
#'@return a prior of class "mixture_normal"
#'@export
update_prior.mixture_normal <- function(G_prior, tpi)
{
if( class(tpi)=="pi_mixture_normal"){
G_prior <- G_prior[[1]]$fitted_g$pi <- tpi
}else{
stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
}
return(G_prior)
}
#'@title Update mixture proportion for mixture normal prior
#'@description
#'@param G a prior of class "mixture_normal"
#'@param tpi a vector of proportion of class"pi_mixture_normal"
#'@return a prior of class "mixture_normal"
#'@export
update_prior.mixture_normal <- function(G_prior, tpi)
{
if( class(tpi)=="pi_mixture_normal"){
G_prior[[1]] <- update_ash_pi(G_prior[[1]], tpi)
}else{
stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
}
return(G_prior)
}
#'@title Update mixture proportion for mixture normal per scale prior
#'@description
#'@param G a prior of class "mixture_normal_per_scale"
#'@param tpi a vector of proportion of class"pi_mixture_normal_per_scale"
#'@return a prior of class "mixture_normal_per_scale"
#'@export
update_prior.mixture_normal_per_scale <- function(G_prior, tpi)
{
if( class(tpi)=="pi_mixture_normal_per_scale"){
out <- mapply(update_ash_pi ,G_prior, tpi, SIMPLIFY = FALSE)
class(out ) <- "mixture_normal_per_scale"
}else{
stop("Error: tpi is not of class pi_mixture_normal_per_scale,\n please compute tpi using generic functions m_step or get_pi_G_prior")
}
return(out)
}
#'@title Update ash object mixture proportion
#'@description
#'@param G a ash object
#'@param tpi a vector of proportion
#'@return an ash object with updated mixture proportion
#'@export
update_ash_pi<- function(G , tpi)
{
if( length(G$fitted_g$pi )==length(tpi))
{
G$fitted_g$pi <- tpi
}else{
stop("Error: when updating ash object length of new mixture proportion
\nlonger than the mixture proportion in the ash object    ")
}
return(G)
}
library(testthat)
library(ashr)
library(wavethresh)
library(Rfast)
set.seed(2)
f1 <- simu_IBSS_per_level(lev_res=9, alpha=1, prop_decay =1.5)
plot(f1$sim_func, type="l", ylab="y")
N=500
P=10
set.seed(23)
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
pos1 <- 5
noisy.data  <- list()
rsnr=10
for ( i in 1:N)
{
f1_obs <- f1$sim_func
noisy.data [[i]] <-   beta1*G[i,pos1]*f1_obs +  rnorm(length(f1$sim_func), sd=  (1/  rsnr ) *sd(f1$sim_func))
}
noisy.data <- do.call(rbind, noisy.data)
Y <- noisy.data
X <- G
W <- DWT2(Y)
update_D <- W
Y_f <- cbind( W$D,W$C) #Using a column like phenotype
update_Y <-Y_f
v1 <- rep(1, dim(X)[2])
tt <-  cal_Bhat_Shat(Y_f,X,v1)
indx_lst <- gen_wavelet_indx(9)
Bhat <- tt$Bhat
Shat <- tt$Shat
### Test validity normal mixture per scale -----
G <- init_prior(Y=Y_f,
X=X,
prior="mixture_normal_per_scale",
v1=v1,
indx_lst = indx_lst)
lBF <- log_BF (G, tt$Bhat, tt$Shat , indx_lst)
lBF
test_that("Max lBF should be in postion",
{
expect_equal(which.max(lBF),
pos1
)
}
)
test_that("Class of the prior is", {
expect_equal(class(
init_prior(Y=Y_f,
X=X,
prior="mixture_normal_per_scale",
v1=v1,
indx_lst = indx_lst)
),
"mixture_normal_per_scale"
)
})
plot( Bhat,  post_mat_mean(G,Bhat,Shat, indx_lst) )
plot( Shat,  (post_mat_sd(G,Bhat,Shat, indx_lst) ))
test_that("Class of the proportions  is", {
expect_equal(class(get_pi_G_prior(G))
,
"pi_mixture_normal_per_scale"
)
})
test_that("Class of the standard deviations  is", {
expect_equal(class(get_sd_G_prior(G))
,
"sd_mixture_normal_per_scale"
)
})
get_pi_G_prior(G)
get_sd_G_prior(G)
L <- L_mixsq(G, Bhat, Shat, indx_lst)
test_that("The likelihood computed by L_mixsqp should be of class", {
L <- L_mixsq(G, Bhat, Shat, indx_lst)
expect_equal(class(L), "lik_mixture_normal_per_scale"
)
})
zeta <- cal_zeta(lBF)
test_that("The highest assignation should be equal to", {
zeta <- cal_zeta(lBF)
expect_equal(which.max(zeta), pos1
)
})
tpi <- m_step(L, zeta , indx_lst)
class(tpi)
test_that("The output of the m_step function should of the class", {
tpi <- m_step(L, zeta , indx_lst)
expect_equal( class(tpi),"pi_mixture_normal_per_scale"
)
})
test_that("The output of the m_step for the pi_0 should equal", {
tpi <- m_step(L, zeta , indx_lst)
expect_equal( get_pi0(tpi = tpi), c(0,0.5, rep(1, 8)),
tolerance = 0.01) #allow 1% error in the proportion estimation
})
G_prior <- G
G_update <- update_prior (G_prior, tpi)
test_that("Updated mixture proportion should be equal to provided input",
{
expect_equal(identical(get_pi_G_prior(G_update) ,tpi),
TRUE
)
}
)
EM_pi(G_prior,Bhat,Shat, indx_lst)
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
class(outEM$lBF)
dim(Bhat)
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
test_that("The outputs of the EM_pi function should be  ",
{
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
expect_equal(class(outEM$tpi_k) ,pi_mixture_normal_per_scale)
expect_equal(class(outEM$lBF) ,"numeric")
expect_equal(length(outEM$lBF) ,dim(Bhat)[1])
expect_equal( get_pi0(tpi = outEM$tpi_k), c(0,0.5, rep(1, 8)),
tolerance = 0.01)
}
)
library(testthat)
library(ashr)
library(wavethresh)
library(Rfast)
set.seed(2)
f1 <- simu_IBSS_per_level(lev_res=9, alpha=1, prop_decay =1.5)
plot(f1$sim_func, type="l", ylab="y")
N=500
P=10
set.seed(23)
G = matrix(sample(c(0, 1,2), size=N*P, replace=T), nrow=N, ncol=P) #Genotype
beta0       <- 0
beta1       <- 1
pos1 <- 5
noisy.data  <- list()
rsnr=10
for ( i in 1:N)
{
f1_obs <- f1$sim_func
noisy.data [[i]] <-   beta1*G[i,pos1]*f1_obs +  rnorm(length(f1$sim_func), sd=  (1/  rsnr ) *sd(f1$sim_func))
}
noisy.data <- do.call(rbind, noisy.data)
Y <- noisy.data
X <- G
W <- DWT2(Y)
update_D <- W
Y_f <- cbind( W$D,W$C) #Using a column like phenotype
update_Y <-Y_f
v1 <- rep(1, dim(X)[2])
tt <-  cal_Bhat_Shat(Y_f,X,v1)
indx_lst <- gen_wavelet_indx(9)
Bhat <- tt$Bhat
Shat <- tt$Shat
### Test validity normal mixture per scale -----
G <- init_prior(Y=Y_f,
X=X,
prior="mixture_normal_per_scale",
v1=v1,
indx_lst = indx_lst)
lBF <- log_BF (G, tt$Bhat, tt$Shat , indx_lst)
lBF
test_that("Max lBF should be in postion",
{
expect_equal(which.max(lBF),
pos1
)
}
)
test_that("Class of the prior is", {
expect_equal(class(
init_prior(Y=Y_f,
X=X,
prior="mixture_normal_per_scale",
v1=v1,
indx_lst = indx_lst)
),
"mixture_normal_per_scale"
)
})
plot( Bhat,  post_mat_mean(G,Bhat,Shat, indx_lst) )
plot( Shat,  (post_mat_sd(G,Bhat,Shat, indx_lst) ))
test_that("Class of the proportions  is", {
expect_equal(class(get_pi_G_prior(G))
,
"pi_mixture_normal_per_scale"
)
})
test_that("Class of the standard deviations  is", {
expect_equal(class(get_sd_G_prior(G))
,
"sd_mixture_normal_per_scale"
)
})
get_pi_G_prior(G)
get_sd_G_prior(G)
L <- L_mixsq(G, Bhat, Shat, indx_lst)
test_that("The likelihood computed by L_mixsqp should be of class", {
L <- L_mixsq(G, Bhat, Shat, indx_lst)
expect_equal(class(L), "lik_mixture_normal_per_scale"
)
})
zeta <- cal_zeta(lBF)
test_that("The highest assignation should be equal to", {
zeta <- cal_zeta(lBF)
expect_equal(which.max(zeta), pos1
)
})
tpi <- m_step(L, zeta , indx_lst)
class(tpi)
test_that("The output of the m_step function should of the class", {
tpi <- m_step(L, zeta , indx_lst)
expect_equal( class(tpi),"pi_mixture_normal_per_scale"
)
})
test_that("The output of the m_step for the pi_0 should equal", {
tpi <- m_step(L, zeta , indx_lst)
expect_equal( get_pi0(tpi = tpi), c(0,0.5, rep(1, 8)),
tolerance = 0.01) #allow 1% error in the proportion estimation
})
G_prior <- G
G_update <- update_prior (G_prior, tpi)
test_that("Updated mixture proportion should be equal to provided input",
{
expect_equal(identical(get_pi_G_prior(G_update) ,tpi),
TRUE
)
}
)
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
test_that("The outputs of the EM_pi function should be  ",
{
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
expect_equal(class(outEM$tpi_k) ,pi_mixture_normal_per_scale)
expect_equal(class(outEM$lBF) ,"numeric")
expect_equal(length(outEM$lBF) ,dim(Bhat)[1])
expect_equal( get_pi0(tpi = outEM$tpi_k), c(0,0.5, rep(1, 8)),
tolerance = 0.01)
}
)
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
test_that("The outputs of the EM_pi function should be  ",
{
outEM <-  EM_pi(G_prior,Bhat,Shat, indx_lst)
expect_equal(class(outEM$tpi_k) ,"pi_mixture_normal_per_scale")
expect_equal(class(outEM$lBF) ,"numeric")
expect_equal(length(outEM$lBF) ,dim(Bhat)[1])
expect_equal( get_pi0(tpi = outEM$tpi_k), c(0,0.5, rep(1, 8)),
tolerance = 0.01)
}
)

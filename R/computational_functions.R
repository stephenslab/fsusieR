################################## susiF computational FUNCTIONS ############################
#'
#'
#'
#' @title EM algorithm to find Empirical Bayes prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior  or mixture  normal per scale
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @param max_step numeric, maximum number of EM iteration
#'
#'
#' @param espsilon numeric, tolerance EM algorithm
#'
#' @return
#'\item{tpi_k}{ fitted mixture proportion}
#'\item{lBF}{ log Bayes Factor}
#'
#' @export
#'
EM_pi <- function(G_prior,Bhat, Shat, indx_lst,
                  max_step = 100,
                  espsilon = 0.0001){

  #static parameters
  Lmat  <-  L_mixsq(G_prior, Bhat, Shat, indx_lst)
  J <- dim(Bhat)[1]
  tsd_k <- get_sd_G_prior(G_prior)

  #dynamic parameters
  tpi_k = get_pi_G_prior(G_prior)
  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration

  lBF <- log_BF(G_prior,Bhat,Shat, indx_lst)

  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    # E step----
    oldloglik <- cal_lik(lBF,zeta)
    zeta      <- cal_zeta(lBF)

    # M step ----
    tpi_k   <- m_step(Lmat,zeta,indx_lst)
    G_prior <- update_prior(G_prior,tpi_k)

    lBF <- log_BF(G_prior,Bhat,Shat,indx_lst)
    newloglik <- cal_lik(lBF,zeta)
    k <- k+1

  }

  out <- list(tpi_k = tpi_k,lBF = lBF)
  class(out) <- c("EM_pi","list")
  return(out)
}

#' @title Regress Y nxJ on X nxp
#'
#' @description regression coefficients (and sd) of the column wise regression
#'
#' @param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'
#' @param X matrix of size n by p in
#'
#' @return list of two
#'
#' \item{Bhat}{ matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j] }
#'
#' \item{Shat}{ matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j] }
#'
#' @export
cal_Bhat_Shat <- function(Y, X, v1,...)
  UseMethod("cal_Bhat_Shat")


#' @rdname cal_Bhat_Shat
#'
#' @method cal_Bhat_Shat  default
#'
#' @export cal_Bhat_Shat. default
#'
#' @export
#'
cal_Bhat_Shat.default  <- function(Y, X, v1)
{
  Bhat  <- list()
  Shat  <- list()

  for ( l in 1:dim(Y)[2])
  {
    out <-  do.call( cbind,lapply( 1:dim(X)[2], function(j) fit_lm(l= l,j=j, Y=Y,X=X, v1=v1  ) ) )
    Bhat[[l]]  <- out[1,]
    Shat[[l]] <- out[2,]
  }

  Bhat <- (do.call(cbind, Bhat))
  Shat <- (do.call(cbind, Shat))
  out  <- list( Bhat = Bhat,
                Shat = Shat)
  return(out)
}

#' @title Regress column l of Y on column j of X
#'
#' @description Add description here.
#'
#' @param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelets that assume that J is of the form J^2. If J is not a power of 2, susiF internally remaps the data into a grid of length 2^J
#'
#' @param X matrix of size n by p in
#'
#' @param v1 vector of 1 of length n
#'
#' @return vector of 2 containing the regression coefficient and standard
#'
#' @importFrom stats var
#'
#' @export
#'
fit_lm <- function( l,j,Y,X,v1)  ## Speed Gain
{

  out <- fast_lm(cbind(v1,X[,j]),Y[,l])
  return(c(out$be[2,1],
           sqrt(
             var(out$residuals)/sum(
               (X[,j]-mean(X[,j]))^2)
           )
  )
  )

}

#' @title Fit ash of coefficient from scale s
#'
#' @description Add description here.
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param s scale of interest
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @return an ash object
#'
#' @importFrom ashr ash
#'
#' @export
#'
fit_ash_level <- function (Bhat, Shat, s, indx_lst)
{
  out <- ash(as.vector(Bhat[,indx_lst[[s]]]),
             as.vector(Shat[,indx_lst[[s]]]),
             mixcompdist = "normal")
  return(out)
}

#' @title Compute Log-Bayes Factor
#'
#' @description Add description here.
#'
#' @param G_prior Mixture normal prior.
#'
#' @param Bhat p x J matrix of regression coefficients;
#' \code{Bhat[j,t]} gives regression coefficient of \code{Y[,t]} on
#' \code{X[,j]}.
#'
#' @param Shat p x J matrix of standard errors; \code{Shat[j,t]}
#'   gives standard error of the regression coefficient of
#'   \code{Y[,t]} on {X[,j]}.
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution, used only with class
#'   \dQuote{mixture_normal_per_scale}
#'
#' @return The log-Bayes factor.
#'
#' @export
#'
log_BF <- function (G_prior, Bhat, Shat, ...)
  UseMethod("log_BF")

#' @rdname log_BF
#'
#' @importFrom stats dnorm
#'
#' @method log_BF mixture_normal
#'
#' @export log_BF.mixture_normal
#'
#' @export
#'
log_BF.mixture_normal <- function (G_prior, Bhat, Shat, ...) {
  t_col_post <- function (t) {
    m    <- G_prior[[1]]
    tt   <- rep(0,length(Shat[t,]))
    pi_k <- m$fitted_g$pi
    sd_k <- m$fitted_g$sd

    # Speed Gain: could potential skip the one that are exactly zero.
    for (k in 1:length(m$fitted_g$pi))
      tt <- tt + pi_k[k] * dnorm(Bhat[t,],sd = sqrt(sd_k[k]^2 + Shat[t,]^2))
    out <- sum(log(tt) - dnorm(Bhat[t,],sd = Shat[t,],log = TRUE))
    return(out)
  }
  out <- lapply(1:nrow(Bhat),FUN = t_col_post)
  lBF <- do.call(c,out)

  # Avoid extreme overflow problem when little noise is present.
  if (prod(is.finite(lBF)) == 0) {
    lBF <- ifelse(lBF==Inf,max(10000, 100*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <- ifelse(lBF== -Inf,max(-10000, -100*max(lBF[-which(lBF== -Inf)])),
                  lBF)
  }

  return(lBF)
}

#' @rdname log_BF
#'
#' @method log_BF mixture_normal_per_scale
#'
#' @export log_BF.mixture_normal_per_scale
#'
#' @export
#'
log_BF.mixture_normal_per_scale <- function (G_prior, Bhat, Shat, indx_lst,
                                             ...) {
  t_col_post <- function (t) {
    t_s_post <- function (s) {
      m <- G_prior[[s]] # Speed Gain: could potential skip the one that are exactly zero.
      data <- set_data(Bhat[t,indx_lst[[s]]],Shat[t,indx_lst[[s]]])
      return(calc_logLR(get_fitted_g(m),data))
    }

    # NOTE: Maybe replace unlist(lapply(...)) with sapply(...).
    return(sum(unlist(lapply(1:log2(ncol(Bhat)), # Important to maintain the ordering of the wavethresh package !!!!
                             t_s_post))))
  }

  out <- lapply(1:nrow(Bhat),FUN = t_col_post)
  lBF <- do.call(c,out)

  if( prod(is.finite(lBF) )==0) # Avoid extreme overflow problem when little noise is present
  {
    lBF <-  ifelse(lBF==Inf,max(10000, 100*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <-  ifelse(lBF== -Inf,max(-10000, -100*max(lBF[-which(lBF== -Inf)])),lBF)
  }

  return(lBF)
}

#' @title Compute posterior mean under mixture normal prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @return pxJ matrix of posterior mean
#'
#' @importFrom ashr get_fitted_g
#'
#' @export

post_mat_mean <- function (G_prior, Bhat, Shat, ...)
  UseMethod("post_mat_mean")


#' @rdname post_mat_mean
#'
#' @method post_mat_mean mixture_normal
#'
#' @export post_mat_mean.mixture_normal
#'
#' @importFrom ashr get_fitted_g
#'
#' @export
#'
post_mat_mean.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t,] ,Shat[t,] )
    return(postmean(get_fitted_g(m),data))
  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

  return(t(do.call(cbind, out)))
}



#' @rdname post_mat_mean
#'
#' @method post_mat_mean mixture_normal_per_scale
#'
#' @export post_mat_mean.mixture_normal_per_scale
#'
#' @importFrom ashr get_fitted_g
#'
#' @export
#'
post_mat_mean.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_m_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(postmean(get_fitted_g(m),data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_m_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(do.call(cbind, out)))
}








#'@title Compute posterior standard deviation under mixture normal prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @importFrom ashr get_fitted_g
#'
#' @return pxJ matrix of posterior standard deviation
#'
#' @export


post_mat_sd <- function (G_prior, Bhat, Shat, ...)
  UseMethod("post_mat_sd")

#' @rdname post_mat_sd
#'
#' @method post_mat_sd mixture_normal
#'
#' @export post_mat_sd.mixture_normal
#'
#' @importFrom ashr get_fitted_g
#'
#' @export
#'
post_mat_sd.mixture_normal  <- function( G_prior ,Bhat,Shat, ...  )
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t, ] ,Shat[t, ] )
    return(postsd(get_fitted_g(m),data))
  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

  return(t(do.call(cbind, out)))
}

#' @rdname post_mat_sd
#'
#' @method post_mat_sd mixture_normal_per_scale
#'
#' @export post_mat_sd.mixture_normal_per_scale
#'
#' @importFrom ashr get_fitted_g
#'
#' @export
#'
post_mat_sd.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_sd_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(postsd(get_fitted_g(m),data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_sd_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(do.call(cbind, out)))
}



#'@title Compute likelihood matrix for mixsqp
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'
#' @return See L argument mixsqp package mixsqp function
#'
#' @export
#'
L_mixsq <- function(G_prior,Bhat, Shat, indx_lst, ...)
  UseMethod("L_mixsq")



#' @rdname L_mixsq
#'
#' @importFrom stats dnorm
#'
#' @method L_mixsq mixture_normal
#'
#' @export L_mixsq.mixture_normal
#'
#' @export
#'
L_mixsq.mixture_normal <- function(G_prior,Bhat, Shat, indx_lst, ...)
{
  m     <-  (G_prior[[1]])
  sdmat <- sqrt(outer(c(Shat ^2),get_sd_G_prior(G_prior)^2,"+"))
  L     <- (
    dnorm(
      outer(
        c(Bhat),
        rep(0,length(get_sd_G_prior(G_prior))),
        FUN="-"
      )/sdmat,
      log=TRUE
    ) -log(sdmat )
  )

  class(L) <- "lik_mixture_normal"
  return(L)
}


#' @rdname L_mixsq
#'
#' @method L_mixsq mixture_normal_per_scale
#'
#' @export L_mixsq.mixture_normal_per_scale
#'
#' @export
#'
L_mixsq.mixture_normal_per_scale <- function(G_prior,Bhat, Shat, indx_lst)
{
  L  <- lapply(1:length(indx_lst  ) , function(s) cal_L_mixsq_s_per_scale (G_prior,s, Bhat, Shat, indx_lst))

  class(L) <- c("lik_mixture_normal_per_scale","list")
  return(L)
}

#' @title Subroutine to compute likelihood matrix at scale s for mixsqp under mixture normal per scale prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @param s scale where the likelihood matrix should be computed
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @return L see L argument mixsqp package mixsqp function
#'
#' @importFrom stats dnorm
#'
#' @export
#'
#'
cal_L_mixsq_s_per_scale <- function(G_prior,s, Bhat, Shat ,indx_lst)
{
  m <-  (G_prior[[s]])
  sdmat <-sqrt(outer(c(Shat[,indx_lst[[s]]]^2),get_sd_G_prior(G_prior)[[s]]^2,"+"))
  L = (dnorm(outer(c(Bhat[,indx_lst[[s]]]),m$fitted_g$mean,FUN="-")/sdmat,log=TRUE) -log(sdmat ))
  return(L)
}

#' @title Compute M step in the weighted ash problem for different prior
#'
#' @description Add description here.
#'
#' @param L output of L_mixsqp function
#'
#' @param zeta assignment probabilities for each covariate
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'
#' @return a vector of proportion (class pi_mixture_normal)
#'
#' @export

m_step <- function(L, zeta, indx_lst, ...)
  UseMethod("m_step")


#' @rdname m_step
#'
#' @importFrom mixsqp mixsqp
#'
#' @method m_step lik_mixture_normal
#'
#' @export m_step.lik_mixture_normal
#'
#' @importFrom mixsqp mixsqp
#'
#' @export
#'
m_step.lik_mixture_normal <- function (L, zeta, indx_lst, ...)
{
  w <- rep(zeta,sum(lengths(indx_lst))) # setting the weight to fit the weighted ash problem
  tlength <- ncol(L) - 1
  mixsqp_out <- mixsqp(L,
                       w,
                       log = TRUE,
                       x0 = c(1,rep(1e-30,tlength)), # put starting point close to sparse solution
                       control = list(
                         eps = 1e-6,
                         numiter.em = 20,
                         verbose = FALSE
                       )
  )
  out <- mixsqp_out$x
  class(out) <-  "pi_mixture_normal"
  return(out)
}

#' @rdname m_step
#'
#' @method m_step lik_mixture_normal_per_scale
#'
#' @export m_step.lik_mixture_normal_per_scale
#'
#' @export
#'
m_step.lik_mixture_normal_per_scale <- function(L, zeta, indx_lst, ...)
{
  #setting the weight to fit the wieghted ash problem


  out <- lapply(1:length(indx_lst) ,
                function(s) scale_m_step(L,s,zeta,indx_lst)
  )
  class( out ) <-  c("pi_mixture_normal_per_scale" )
  return(out)

}

#'@title Subroutine to compute M step in the weighted ash problem for normal mixture prior per scale at a given scale s
#'
#' @description Add description here.
#'
#' @param L output of the L_mixsqp.mixture_normal_per_scale function
#'
#' @param s scale
#'
#' @param zeta assignment probabilities for each covariate
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'
#' @return a vector of proportion for the scale s
#'
#' @importFrom mixsqp mixsqp
#'
#' @export
scale_m_step <- function(L,s,zeta, indx_lst)
{
  w <- rep(zeta,length(indx_lst[[s]] ))
  tlength <- dim(L[[s]])[2]-1
  mixsqp_out <- mixsqp( L[[s]] ,
                        w,
                        x0 = c(1, rep(1e-30,  tlength )),
                        log=TRUE ,
                        control = list(
                          eps = 1e-6,
                          numiter.em = 20,
                          verbose=FALSE
                        )
  )

  out <- mixsqp_out$x
  return( out)

}
#' @title Compute assignment probabilities from log Bayes factors
#'
#' @description Add description here.
#'
#' @param lBF vector of log Bayes factors
#' @export
cal_zeta <- function(lBF)
{
  out <- exp(lBF - max(lBF ) ) /sum( exp(lBF - max(lBF ) ))
  return(out)
}

#' @title Compute likelihood for the weighted ash problem
#'
#' @description Add description here.
#'
#' @param lBF vector of log Bayes factors
#'
#' @param zeta assignment probabilities
#'
#' @return Likelihood value
#'
#' @export
#'
cal_lik <- function(lBF,zeta)
{
  out <- sum( zeta*exp(lBF - max(lBF ) ))
  return(out)
}


################################## susiF computational FUNCTIONS ############################
#'
#'
#'
#' @title EM algorithm to select mixture weight in a  Empirical Bayes way
#'
#' @description Select the mixture weight by maximizing the marginal likelihood
#'
#' @param G_prior mixture normal prior  or mixture  normal per scale
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @param max_step numeric, maximum number of EM iteration
#'
#' @param init_pi0_w starting value of weight on null compoenent in mixsqp
#'
#' @param control_mixsqp list of parameter for mixsqp function see\link{\code{mixsqp}}
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#' @param espsilon numeric, tolerance EM algorithm
#'
#'  @param nullweight numeric value for penalizing likelihood at point mass 0 (should be between 0 and 1)
#' (usefull in small sample size)
#' @return
#'\item{tpi_k}{ fitted mixture proportion}
#'\item{lBF}{ log Bayes Factor}
#'
#' @export
#'
EM_pi <- function(G_prior,Bhat, Shat, indx_lst,
                  max_step = 100,
                  espsilon = 0.0001,
                  init_pi0_w =1,
                  control_mixsqp,
                  lowc_wc,
                  nullweight){

  #static parameters
  Lmat  <-  L_mixsq(G_prior, Bhat, Shat, indx_lst)
  J <- dim(Bhat)[1]
  tsd_k <- get_sd_G_prior(G_prior)

  #dynamic parameters
  tpi_k = get_pi_G_prior(G_prior)
  oldloglik <-0
  newloglik <-1

  zeta <- rep(1/J,J) #assignation initial value
  k <- 1 #counting the number of iteration

  lBF <- log_BF(G_prior,Bhat,Shat, indx_lst=indx_lst, lowc_wc=lowc_wc)

  while( k <max_step &  abs(newloglik-oldloglik)>=espsilon)
  {
    # E step----
    oldloglik <- cal_lik(lBF,zeta)
    zeta      <- cal_zeta(lBF)

    # M step ----
    tpi_k   <- m_step(Lmat,zeta,indx_lst,
                      init_pi0_w     = init_pi0_w,
                      control_mixsqp = control_mixsqp,
                      nullweight     = nullweight)
    G_prior <- update_prior(G_prior,tpi_k)

    lBF <-  log_BF(G_prior,Bhat,Shat, indx_lst=indx_lst, lowc_wc=lowc_wc)
    newloglik <- cal_lik(lBF,zeta)
    k <- k+1

  }

  out <- list(tpi_k = tpi_k,lBF = lBF)
  class(out) <- c("EM_pi","list")
  return(out)
}

#' @title Regress Y nxJ on X nxp
#'
#' @description regression coefficients (and sd) of the column wise regression
#'
#' @param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'
#' @param X matrix of size n by p in
#'
#' @param v1 vector of ones of length n
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#'
#' @return list of two
#'
#' \item{Bhat}{ matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j] }
#'
#' \item{Shat}{ matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j] }
#'
#' @export
cal_Bhat_Shat <- function(Y, X,v1, lowc_wc, ...)
  UseMethod("cal_Bhat_Shat")


#' @rdname cal_Bhat_Shat
#'
#' @method cal_Bhat_Shat  default
#'
#' @export cal_Bhat_Shat.default
#'
#' @export
#'
cal_Bhat_Shat.default  <- function(Y, X ,v1 , lowc_wc=NULL  )
{

  out <- t(mapply( function(j,l) fit_lm(l= l, j=j, Y=Y ,X=X,v1=v1, lowc_wc=lowc_wc  ),
                   l=rep(1:dim(Y)[2],each= ncol(X)),
                   j=rep(1:dim(X)[2], ncol(Y))))

  Bhat   <-  matrix(  out[,1], nrow=ncol(X))
  Shat   <-  matrix(  out[,2], nrow=ncol(X))

  out  <- list( Bhat = Bhat,
                Shat = Shat)

  return(out)
}

#' @title Regress column l of Y on column j of X
#'
#' @description Regress column l of Y on column j of X
#'
#' @param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelets that assume that J is of the form J^2. If J is not a power of 2, susiF internally remaps the data into a grid of length 2^J
#'
#' @param X matrix of size n by p in
#'
#' @param v1 vector of 1 of length n
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#'
#' @return vector of 2 containing the regression coefficient and standard error
#'
#' @importFrom stats var
#'
#' @export
#'
fit_lm <- function( l,j,Y,X,v1, lowc_wc =NULL )  ## Speed Gain
{

  if( !is.null(lowc_wc)){

    if (l %in%lowc_wc){
      return(c(0,
               1
               )
            )

    }else{


      return(  fast_lm(x=X[,j] ,
                       y= Y[,l]
                      )
            )
    }

  }else{
    return(  fast_lm(X[,j] ,
                    Y[,l]
                    )
           )
  }





}

#' @title Fit ash of coefficient from scale s
#'
#' @description Add description here.
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param s scale of interest
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#' @return an ash object
#'
#' @importFrom ashr ash
#'
#' @export
#'
fit_ash_level <- function (Bhat, Shat, s, indx_lst, lowc_wc)
{
  if( !is.null(lowc_wc)){


    t_ind <-indx_lst[[s]]
    t_ind <-  t_ind[which(t_ind %!in% lowc_wc)]


    if( length(t_ind)==0){ #create a ash object with full weight on null comp
      out <- ash(rnorm(100, sd=0.1),
                 rep(1,100),
                 mixcompdist = "normal" ,
                 outputlevel=0)
      out$fitted_g$pi  <- c(1, rep(0, (length(out$fitted_g$pi )-1) ))
    }else{
      out <- ash(as.vector(Bhat[,t_ind]),
                 as.vector(Shat[,t_ind]),
                 mixcompdist = "normal" ,
                 outputlevel=0)
    }

  }else{
    out <- ash(as.vector(Bhat[,indx_lst[[s]]]),
               as.vector(Shat[,indx_lst[[s]]]),
               mixcompdist = "normal" ,
               outputlevel=0)
  }

  return(out)
}

#' @title Compute Log-Bayes Factor
#'
#' @description Compute Log-Bayes Factor
#'
#' @param G_prior Mixture normal prior.
#'
#' @param Bhat p x J matrix of regression coefficients;
#' \code{Bhat[j,t]} gives regression coefficient of \code{Y[,t]} on
#' \code{X[,j]}.
#'
#' @param Shat p x J matrix of standard errors; \code{Shat[j,t]}
#'   gives standard error of the regression coefficient of
#'   \code{Y[,t]} on {X[,j]}.
#'
#' @param indx_list List generated by \code{\link{gen_wavelet_indx}}
#'   for the given level of resolution, used only with class
#'   \dQuote{mixture_normal_per_scale}
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#' @return  The log-Bayes factor for each covariate.
#'
#' @export
#'
log_BF <- function (G_prior, Bhat, Shat,lowc_wc, ...)
  UseMethod("log_BF")

#' @rdname log_BF
#'
#' @importFrom stats dnorm
#'
#' @method log_BF mixture_normal
#'
#' @export log_BF.mixture_normal
#'
#' @export
#'
log_BF.mixture_normal <- function (G_prior, Bhat, Shat,lowc_wc, ...) {
  t_col_post <- function (t,lowc_wc) {

    m    <- G_prior[[1]]
    if(!is.null(lowc_wc)){
      tt   <- rep(0,length(Shat[t,-lowc_wc] ))
    }else{
      tt   <- rep(0,length(Shat[t,]))
    }

    pi_k <- m$fitted_g$pi
    sd_k <- m$fitted_g$sd

    # Speed Gain: could potential skip the one that are exactly zero.
    # Speed Gain: could potential skip the one that are exactly zero.


    if(!is.null(lowc_wc)){
      for (k in 1:length(m$fitted_g$pi))
      {
        tt <- tt + pi_k[k] * dnorm(Bhat[t,-lowc_wc],sd = sqrt(sd_k[k]^2 + Shat[t,-lowc_wc]^2))
      }
      out <- sum(log(tt) - dnorm(Bhat[t,-lowc_wc],sd = Shat[t,-lowc_wc],log = TRUE))
    }else{
      for (k in 1:length(m$fitted_g$pi))
      {
        tt <- tt + pi_k[k] * dnorm(Bhat[t,],sd = sqrt(sd_k[k]^2 + Shat[t,]^2))
      }
      out <- sum(log(tt) - dnorm(Bhat[t,],sd = Shat[t,],log = TRUE))
    }

   # tt <- ifelse(tt==Inf,max(10000, 100*max(tt[-which(tt==Inf)])),tt)

    return(out)
  }
  out <- lapply(1:nrow(Bhat),function(k) t_col_post(k, lowc_wc))
  lBF <- do.call(c,out)

  # Avoid extreme overflow problem when little noise is present.
  if (prod(is.finite(lBF)) == 0) {
    lBF <- ifelse(lBF==Inf,max(10000, 100*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <- ifelse(lBF== -Inf,max(-10000, -100*max(lBF[-which(lBF== -Inf)])),
                  lBF)
  }

  return(lBF)
}

#' @rdname log_BF
#'
#' @method log_BF mixture_normal_per_scale
#'
#' @export log_BF.mixture_normal_per_scale
#'
#' @importFrom ashr set_data
#'
#'
#'
#' @export
#'
log_BF.mixture_normal_per_scale <- function (G_prior, Bhat, Shat, indx_lst, lowc_wc,
                                             ...) {
  t_col_post <- function (t) {
    t_s_post <- function (s) {

      if( !is.null(lowc_wc)){


        t_ind <-indx_lst[[s]]
        t_ind <-  t_ind[which(t_ind %!in% lowc_wc)]

        if( length(t_ind)==0){ #create a ash object with full weight on null comp
          return(0)
        }else{
          m <- G_prior[[s]] # Speed Gain: could potential skip the one that are exactly zero.
          data <- set_data(Bhat[t,t_ind],Shat[t,t_ind])
          return(calc_logLR(get_fitted_g(m),data))
        }
      }

      else{
        m <- G_prior[[s]] # Speed Gain: could potential skip the one that are exactly zero.
        data <- set_data(Bhat[t,indx_lst[[s]]],Shat[t,indx_lst[[s]]])
        return(calc_logLR(get_fitted_g(m),data))
      }

    }

    # NOTE: Maybe replace unlist(lapply(...)) with sapply(...).
    return(sum(unlist(lapply(1:(log2(ncol(Bhat))+1), # Important to maintain the ordering of the wavethresh package !!!!
                             t_s_post))))
  }

  out <- lapply(1:nrow(Bhat),FUN = t_col_post)
  lBF <- do.call(c,out)

  if( prod(is.finite(lBF) )==0) # Avoid extreme overflow problem when little noise is present
  {
    lBF <-  ifelse(lBF==Inf,max(10000, 100*max(lBF[-which(lBF==Inf)])),lBF)
    lBF <-  ifelse(lBF== -Inf,max(-10000, -100*max(lBF[-which(lBF== -Inf)])),lBF)
  }

  return(lBF)
}

#' @title Compute posterior mean under mixture normal prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#' @return pxJ matrix of posterior mean
#'
#'
#'
#' @export

post_mat_mean <- function (G_prior, Bhat, Shat,lowc_wc, ...)
  UseMethod("post_mat_mean")


#' @rdname post_mat_mean
#'
#' @method post_mat_mean mixture_normal
#'
#' @export post_mat_mean.mixture_normal
#'
#'
#'
#' @importFrom ashr set_data
#'
#' @export
#'
post_mat_mean.mixture_normal  <- function( G_prior ,Bhat,Shat,indx_lst,lowc_wc, ...  )
{
  if(!is.null(lowc_wc)){
    t_col_post <- function(t){
      m <- G_prior [[1]]
      data <-  set_data(Bhat[t,-lowc_wc] ,Shat[t,-lowc_wc] )
      return(postmean(get_fitted_g(m),data))
    }
  }else{
    t_col_post <- function(t){
      m <- G_prior [[1]]
      data <-  set_data(Bhat[t, ] ,Shat[t,] )
      return(postmean(get_fitted_g(m),data))
    }
  }


  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

   return(t(Reduce("cbind", out)))
}



#' @rdname post_mat_mean
#'
#' @method post_mat_mean mixture_normal_per_scale
#'
#' @export post_mat_mean.mixture_normal_per_scale
#'
#' @export
#'
#' @importFrom ashr set_data
post_mat_mean.mixture_normal_per_scale <- function( G_prior,Bhat,Shat, indx_lst,lowc_wc, ...  )
{



  if( !is.null(lowc_wc)){

    t_col_post <- function(t ){

      t_m_post <- function(s){
        m <- G_prior [[ s]]

        t_ind <-indx_lst[[s]]
        t_ind <-  t_ind[which(t_ind %!in% lowc_wc)]



        data <-  set_data(Bhat[t,t_ind ],
                          Shat[t,t_ind ])

        return(postmean(get_fitted_g(m),data))
      }

      temp <- c()#discard level of resolution with complelty zero coefficients
      for (s in 1:length(indx_lst))
      {

        t_ind <-indx_lst[[s]]
        t_ind <-  t_ind[which(t_ind %!in% lowc_wc)]
        #print(  which(t_ind %!in% lowc_wc))

        if( length(t_ind)==0){
          temp <- c(temp,s)
        }
      }
      # temp
      t_indx <-  c((length(indx_lst)  -1): 1,length(indx_lst)   )
      if(length(temp)>0){#check if at least one level has to be discarded
        t_indx <- t_indx[- which(t_indx %in% temp)]
      }
      return(unlist(lapply(t_indx , #important to maintain the ordering of the wavethresh package !!!!
                           t_m_post )))
    }


  }else{
    t_col_post <- function(t  ){

      t_m_post <- function(s ){
        m <- G_prior [[ s]]

        data <-  set_data(Bhat[t,indx_lst[[s]] ],
                          Shat[t, indx_lst[[s]] ]
        )
        return(postmean(get_fitted_g(m),data))
      }
      return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                            t_m_post  )
      )
      )
    }


  }
  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)



  return(t(Reduce("cbind", out)))
}


#'@title Compute posterior standard deviation under mixture normal prior
#'
#' @description Compute posterior standard deviation under mixture normal prior
#'
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#' @return pxJ matrix of posterior standard deviation
#'
#' @export


post_mat_sd <- function (G_prior, Bhat, Shat,lowc_wc, ...)
  UseMethod("post_mat_sd")

#' @rdname post_mat_sd
#'
#' @method post_mat_sd mixture_normal
#'
#' @export post_mat_sd.mixture_normal
#'
#'
#'
#' @importFrom ashr set_data
#'
#' @export
#'
post_mat_sd.mixture_normal  <- function( G_prior ,Bhat,Shat,indx_lst,lowc_wc, ...  )
{
  if(!is.null(lowc_wc)){
    t_col_post <- function(t){
      m <- G_prior [[1]]
      data <-  set_data(Bhat[t, -lowc_wc] ,Shat[t,-lowc_wc ] )
      return(postsd(get_fitted_g(m),data))
    }

  }else{
    t_col_post <- function(t){
      m <- G_prior [[1]]
      data <-  set_data(Bhat[t,  ] ,Shat[t, ] )
      return(postsd(get_fitted_g(m),data))
    }

  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )

  return(t(Reduce("cbind", out)))
}

#' @rdname post_mat_sd
#'
#' @method post_mat_sd mixture_normal_per_scale
#'
#' @export post_mat_sd.mixture_normal_per_scale
#'
#'
#'
#' @importFrom ashr set_data
#'
#' @export
#'
post_mat_sd.mixture_normal_per_scale <-  function( G_prior ,Bhat,Shat, indx_lst, lowc_wc, ...  )
{

  if( !is.null(lowc_wc)){

    t_col_post <- function(t ){

      t_sd_post <- function(s){
        m <- G_prior [[ s]]

        t_ind <-indx_lst[[s]]
        t_ind <-  t_ind[which(t_ind %!in% lowc_wc)]



        data <-  set_data(Bhat[t,t_ind ],
                          Shat[t,t_ind ])

        return(postsd(get_fitted_g(m),data))
      }

      temp <- c()#discard level of resolution with complelty zero coefficients
      for (s in 1:length(indx_lst))
      {

        t_ind <-indx_lst[[s]]
        t_ind <-  t_ind[which(t_ind %!in% lowc_wc)]
        #print(  which(t_ind %!in% lowc_wc))

        if( length(t_ind)==0){
          temp <- c(temp,s)
        }
      }
      # temp
      t_indx <-  c((length(indx_lst)  -1): 1,length(indx_lst)   )
      if(length(temp)>0){#check if at least one level has to be discarded
        t_indx <- t_indx[- which(t_indx %in% temp)]
      }
      return(unlist(lapply(t_indx , #important to maintain the ordering of the wavethresh package !!!!
                           t_sd_post )))
    }


  }else{
    t_col_post <- function(t  ){

      t_sd_post <- function(s ){
        m <- G_prior [[ s]]

        data <-  set_data(Bhat[t,indx_lst[[s]] ],
                          Shat[t, indx_lst[[s]] ]
        )
        return(postsd(get_fitted_g(m),data))
      }
      return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                            t_sd_post  )
      )
      )
    }


  }
  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)

  return(t(Reduce("cbind", out)))
}


#' @title Compute conditional local false sign rate
#'
#' @description Compute conditional local false sign rate
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#'
#'
#' @return pxJ matrix of local false sign rate
#'
#' @export


cal_clfsr <- function (G_prior, Bhat, Shat, ...)
  UseMethod("cal_clfsr")


#' @rdname cal_clfsr
#'
#' @method cal_clfsr mixture_normal
#'
#' @export cal_clfsr.mixture_normal
#'
#'
#'
#' @importFrom ashr set_data
#' @importFrom ashr get_fitted_g
#' @export
#'
cal_clfsr.mixture_normal  <- function(G_prior, Bhat,Shat, ...)
{
  t_col_post <- function(t){
    m <- G_prior [[1]]
    data <-  set_data(Bhat[t,] ,Shat[t,] )
    return(calc_lfsr( m ,data))
  }

  out <- lapply(1:(dim(Bhat)[1] ),t_col_post )
  out <- t(Reduce("cbind", out))
  class(out) <- "clfsr_wc"
  return(out)
}


#' @rdname cal_clfsr
#'
#' @method cal_clfsr mixture_normal_per_scale
#'
#' @export cal_clfsr.mixture_normal_per_scale
#'
#'
#'
#' @importFrom ashr set_data
#' @importFrom ashr get_fitted_g
#'
#' @export
#'

cal_clfsr.mixture_normal_per_scale <- function( G_prior ,Bhat,Shat, indx_lst, ...  )
{
  t_col_post <- function(t ){

    t_m_post <- function(s){
      m <- G_prior [[ s]]

      data <-  set_data(Bhat[t,indx_lst[[s]] ],
                        Shat[t, indx_lst[[s]] ]
      )
      return(calc_lfsr( m ,data))
    }
    return(unlist(lapply( c((length(indx_lst)  -1): 1,length(indx_lst)   ), #important to maintain the ordering of the wavethresh package !!!!
                          t_m_post )))
  }

  out <- lapply( 1:(dim(Bhat)[1]),
                 FUN= t_col_post)


  out <- t(Reduce("cbind", out))

  return(out)
}



#'@title Compute conditional local false sign rate
#' @description Compute conditional local false sign rate
#'
#' @param lfsr_mat an object of the class "clfsr_wc" generated by \code{\link{cal_clfsr}}
#'
#' @param alpha  vector of length P containning
#'
#' @return  J local false sign rate
#'
#' @export


cal_lfsr  <- function (clfsr_wc, alpha){
  out <-  c(alpha %*%clfsr_wc)
  return( out)
}

#'@title Compute likelihood matrix for mixsqp
#'
#' @description Compute likelihood matrix for mixsqp
#'
#' @param G_prior mixture normal prior
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'
#' @return See L argument mixsqp package mixsqp function
#'
#' @export
#'
L_mixsq <- function(G_prior,Bhat, Shat, indx_lst, nullweight, ...)
  UseMethod("L_mixsq")

#### Potential speed gain heree ------

#' @rdname L_mixsq
#'
#' @importFrom stats dnorm
#'
#' @method L_mixsq mixture_normal
#'
#' @export L_mixsq.mixture_normal
#'
#' @export
#'
L_mixsq.mixture_normal <- function(G_prior,Bhat, Shat, indx_lst,   ...)
{
  m     <-  (G_prior[[1]])
  sdmat <- sqrt(outer(c(Shat ^2),get_sd_G_prior(G_prior)^2,"+"))
  L     <- (
    dnorm(
      outer(
        c(Bhat),
        rep(0,length(get_sd_G_prior(G_prior))),
        FUN="-"
      )/sdmat,
      log=TRUE
    ) -log(sdmat )
  )
#dealing in case of due to small sd due to small sample size
  L     <-  apply(L, 2, function(x){
                                       x[which(is.na(x))] <- median(x, na.rm=T)
                                      return(x)
                                      })
  L <- rbind(c(0, rep(  -1e+30,(ncol(L)-1)  )),#adding penalty line
             L)
  class(L) <- "lik_mixture_normal"
  return(L)
}


#' @rdname L_mixsq
#'
#' @method L_mixsq mixture_normal_per_scale
#'
#' @export L_mixsq.mixture_normal_per_scale
#'
#' @export
#'
L_mixsq.mixture_normal_per_scale <- function(G_prior,Bhat, Shat, indx_lst, nullweight)
{
  L  <- lapply(1:length(indx_lst  ) , function(s) cal_L_mixsq_s_per_scale (G_prior,s, Bhat, Shat, indx_lst))

  class(L) <- c("lik_mixture_normal_per_scale","list")
  return(L)
}

#' @title Subroutine to compute likelihood matrix at scale s for mixsqp under mixture normal per scale prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @param s scale where the likelihood matrix should be computed
#'
#' @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#'
#' @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class mixture_normal_per_scale
#'
#' @return L see L argument mixsqp package mixsqp function
#'
#' @importFrom stats dnorm
#'
#' @export
#'
#'
cal_L_mixsq_s_per_scale <- function(G_prior,s, Bhat, Shat ,indx_lst)
{
  m <-  (G_prior[[s]])
  sdmat <-sqrt(outer(c(Shat[,indx_lst[[s]]]^2),get_sd_G_prior(G_prior)[[s]]^2,"+"))
  L = (dnorm(outer(c(Bhat[,indx_lst[[s]]]),m$fitted_g$mean,FUN="-")/sdmat,log=TRUE) -log(sdmat ))
  #dealing in case of due to small sd due to small sample size
  L     <-  apply(L, 2, function(x){
    x[which(is.na(x))] <- median(x, na.rm=T)
    return(x)
  })
  L <- rbind(c(0, rep(  -1e+30,(ncol(L)-1)  )),#adding penalty line
             L)
  return(L)
}

#' @title Compute M step in the weighted ash problem for different prior
#'
#' @description Compute M step in the weighted ash problem for different prior
#'
#' @param L output of \code{\link{L_mixsqp}} function
#'
#' @param zeta assignment probabilities for each covariate
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#' @param init_pi0_w starting value of weight on null compoenent in mixsqp
#' @param control_mixsqp list of parameter for mixsqp function see\link{\code{mixsqp}}
#'
#' @return a vector of proportion (class pi_mixture_normal)
#'
#' @export

m_step <- function(L, zeta, indx_lst,init_pi0_w,control_mixsqp, ...)
  UseMethod("m_step")


#' @rdname m_step
#'
#' @importFrom mixsqp mixsqp
#'
#' @method m_step lik_mixture_normal
#'
#' @export m_step.lik_mixture_normal
#'
#' @importFrom mixsqp mixsqp
#'
#' @export
#'
m_step.lik_mixture_normal <- function (L, zeta, indx_lst,init_pi0_w ,control_mixsqp, nullweight,  ...)
{
  w <- c(nullweight*sum(lengths(indx_lst)),
         rep(zeta,sum(lengths(indx_lst))) # setting the weight to fit the weighted ash problem
         )


  tlength <- ncol(L) - 1

  mixsqp_out <- mixsqp(L,
                       w,
                       log = TRUE,
                       x0 = c(init_pi0_w ,rep(1e-6,tlength)), # put starting point close to sparse solution
                       control = control_mixsqp
                       )
  out <- mixsqp_out$x
  class(out) <-  "pi_mixture_normal"
  return(out)
}

#' @rdname m_step
#'
#' @method m_step lik_mixture_normal_per_scale
#'
#' @export m_step.lik_mixture_normal_per_scale
#'
#' @export
#'
m_step.lik_mixture_normal_per_scale <- function(L, zeta, indx_lst,init_pi0_w=1,control_mixsqp, nullweight,...)
{
  #setting the weight to fit the weighted ash problem


  out <- lapply(1:length(indx_lst) ,
                                    function(s) scale_m_step(L,s,zeta,indx_lst,
                                                             init_pi0_w=init_pi0_w,
                                                             control_mixsqp = control_mixsqp,
                                                             nullweight     =  nullweight )
                )
  class( out ) <-  c("pi_mixture_normal_per_scale" )
  return(out)

}

#'@title Subroutine to compute M step in the weighted ash problem for normal mixture prior per scale at a given scale s
#'
#' @description  Subroutine to compute M step in the weighted ash
#'
#' @param L output of the L_mixsqp.mixture_normal_per_scale function
#'
#' @param s scale
#'
#' @param zeta assignment probabilities for each covariate
#'
#' @param indx_list list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#' @param init_pi0_w starting value of weight on null compoenent in mixsqp
#' @param control_mixsqp list of parameter for mixsqp function see\link{\code{mixsqp}}
#'
#' @return a vector of proportion for the scale s
#'
#' @importFrom mixsqp mixsqp
#'
#' @export
scale_m_step <- function(L,s,zeta, indx_lst,init_pi0_w=0.5,  control_mixsqp, nullweight,...)
{

  w <-  c(nullweight*length(indx_lst[[s]] ),
          rep(zeta,length(indx_lst[[s]] ))
          )


  tlength <- dim(L[[s]])[2]-1

  mixsqp_out <- mixsqp( L[[s]] ,
                        w,
                        x0 = c(init_pi0_w, rep(1e-6,  tlength )),
                        log=TRUE ,
                        control = control_mixsqp
                      )

  out <- mixsqp_out$x
  return( out)

}
#' @title Compute assignment probabilities from log Bayes factors
#'
#' @description Add description here.
#'
#' @param lBF vector of log Bayes factors
#' @export
cal_zeta <- function(lBF)
{
  out <- exp(lBF - max(lBF ) ) /sum( exp(lBF - max(lBF ) ))
  return(out)
}

#' @title Compute likelihood for the weighted ash problem
#'
#' @description Add description here.
#'
#' @param lBF vector of log Bayes factors
#'
#' @param zeta assignment probabilities
#'
#' @return Likelihood value
#'
#' @export
#'
cal_lik <- function(lBF,zeta)
{
  out <- sum( zeta*exp(lBF - max(lBF ) ))
  return(out)
}




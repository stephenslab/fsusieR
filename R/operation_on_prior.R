################################## SuSiF operation on prior ############################
#'
#'
#'
#'
#'#'@title Initialise the prior
#'
#'@description generate list of object corresponding to the parameters of the prior set for analysis
#'@param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'@param X matrix of size n by p in
#'@param prior Three choice are available "normal", "mixture_normal", "mixture_normal_per_scale"
#'@param indx_lst list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'@return an object of the class "normal", "mixture_normal" or "mixture_normal_per_scale"
#'@export
init_prior <- function(Y,X, prior,v1 , indx_lst )
{
  if( prior == "mixture_normal")
  {

    temp <- cal_Bhat_Shat(Y,X,v1 )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function

    G_prior <- list()
    G_prior[[1]]  <-  ash(c(temp$Bhat), c(temp$Shat),mixcompdist ="normal")
    attr(G_prior, "class") <- "foo" <- "mixture_normal"
  }

  if( prior == "mixture_normal_per_scale")
  {

    temp <- cal_Bhat_Shat(Y,X,v1 )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function
    G_prior  <-  lapply(1: (log2(dim(Y)[2])+1) ,
                        FUN= function(s) fit_ash_level(  Bhat=temp$Bhat, temp$Shat,s=s, indx_lst ) )
    #first log2(Y_f)+1 element of G_prior   are ash prior fitted per level coefficient on var 1
    # element in  (log2(Y_f)+2):  2*( log2(Y_f)+1)   of G_prior   are ash prior fitted per level coefficient on var 2

    attr(G_prior, "class") <- "mixture_normal_per_scale"
  }

  return(G_prior)

}


#'@title Get mixture proportion for mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@return vector of mixture proportion
#'@export
get_pi_G_prior.mixture_normal <- function(G_prior)
{
  out <- G_prior[[1]]$fitted_g$pi
  class(out)  <- "pi_mixture_normal"
  return(out)
}

#'@title Get mixture proportion for mixture normal prior per scale
#'
#'@description
#'@param G_prior mixture normal prior
#'@return list of vector of mixture proportion
#'@export
get_pi_G_prior.mixture_normal_per_scale <- function(G_prior)
{
  out <- lapply(G_prior, function(x) x$fitted_g$pi)
  class(out) <- "pi_mixture_normal_per_scale"
  return(out)
}


#'@title Get mixture proportion for mixture normal prior per scale
#'
#'@description
#'@param G_prior mixture normal prior
#'@return list of vector of mixture proportion
#'@export
get_pi0.mixture_normal <- function(G_prior)
{
  out <- get_pi_G_prior(G_prior)[1]
  return(out)
}

#'@title Get mixture proportion for mixture normal prior
#'
#'@description
#'@param tpi  object of class pi_mixture_normal
#'@return numeric between 0 an 1
#'@export
get_pi0.pi_mixture_normal  <- function(tpi)
{
  out <- tpi[1]
  return(out)
}


#'@title Get mixture proportion for of the null component in mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@return A number between 0 and 1
#'@export
get_pi0.mixture_normal_per_scale <- function(G_prior)
{
  pi_prior_list <- get_pi_G_prior(G_prior)
  out <-  lapply(pi_prior_list, function(x){unlist( lapply(x, function(y) y[1])) } )
  return(out)
}

#'@title Get mixture proportion for mixture normal prior
#'
#'@description
#'@param tpi  object of class pi_mixture_normal
#'@return A number between 0 and 1
#'@export
get_pi0.pi_mixture_normal_per_scale  <- function(tpi)
{
  out <-    (unlist(lapply(tpi, function(y) y[[1]][1]) ))
  return(out)
}


#'@title Get mixture standard deviations for mixture normal prior
#'
#'@description
#'@param G_prior mixture normal prior
#'@return vector of standard deviations
#'@export
get_sd_G_prior.mixture_normal <- function(G_prior)
{
  out <- G_prior[[1]]$fitted_g$sd
  class(out) <- "sd_mixture_normal"
  return(out)
}



#'@title Get mixture standard deviations mixture normal prior per scale
#'
#'@description
#'@param G_prior mixture normal prior
#'@return list of vectors of standard deviations
#'@export
get_sd_G_prior.mixture_normal_per_scale <- function(G_prior)
{
  out <- lapply(G_prior, function(x) x$fitted_g$sd)
  class(out) <- "sd_mixture_normal_per_scale"
  return(out)
}





#'@title Update mixture proportion for mixture normal prior
#'@description
#'@param G_prior a prior of class "mixture_normal"
#'@param tpi a vector of proportion of class"pi_mixture_normal"
#'@return a prior of class "mixture_normal"
#'@export
update_prior.mixture_normal <- function(G_prior, tpi)
{
  if( class(tpi)=="pi_mixture_normal"){
    G_prior <- G_prior[[1]]$fitted_g$pi <- tpi
  }else{
    stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(G_prior)
}


#'@title Update mixture proportion for mixture normal prior
#'@description
#'@param G_prior a prior of class "mixture_normal"
#'@param tpi a vector of proportion of class"pi_mixture_normal"
#'@return a prior of class "mixture_normal"
#'@export
update_prior.mixture_normal <- function(G_prior, tpi)
{
  if( class(tpi)=="pi_mixture_normal"){
    G_prior[[1]] <- update_ash_pi(G_prior[[1]], tpi)
  }else{
    stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(G_prior)
}

#'@title Update mixture proportion for mixture normal per scale prior
#'@description
#'@param G_prior a prior of class "mixture_normal_per_scale"
#'@param tpi a vector of proportion of class"pi_mixture_normal_per_scale"
#'@return a prior of class "mixture_normal_per_scale"
#'@export
update_prior.mixture_normal_per_scale <- function(G_prior, tpi)
{
  if( class(tpi)=="pi_mixture_normal_per_scale"){
    out <- mapply(update_ash_pi ,G_prior, tpi, SIMPLIFY = FALSE)
    class(out ) <- "mixture_normal_per_scale"
  }else{
    stop("Error: tpi is not of class pi_mixture_normal_per_scale,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(out)
}

#'@title Update ash object mixture proportion
#'@description
#'@param G_prior a ash object
#'@param tpi a vector of proportion
#'@return an ash object with updated mixture proportion
#'@export
update_ash_pi<- function(G , tpi)
{

  if( length(G$fitted_g$pi )==length(tpi))
  {
    G$fitted_g$pi <- tpi
  }else{
    stop("Error: when updating ash object length of new mixture proportion
    \nlonger than the mixture proportion in the ash object    ")

  }

  return(G)
}


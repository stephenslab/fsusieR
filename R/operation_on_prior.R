################################## SuSiF operation on prior ############################
#'
#'
#'
#'
#'



#' @title Initialize the prior
#'
#' @description generate list of object corresponding to the parameters of the prior set for analysis
#'
#' @return an object of the class "normal", "mixture_normal" or "mixture_normal_per_scale"
#'
#' @export

init_prior <- function(  ...)
  UseMethod("init_prior")


#' @title Initialize the prior
#'
#' @description generate list of object corresponding to the parameters of the prior
#'
#' @param Y  functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susif internally remaps the data into grid of length 2^J
#'
#' @param X matrix of size n by p in
#'
#' @param prior Three choice are available "normal", "mixture_normal", "mixture_normal_per_scale"
#'
#' @param indx_lst list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'
#' @param lowc_wc wavelet coefficient with low count to be discarded
#'
#' @return an object of the class "normal", "mixture_normal" or "mixture_normal_per_scale"
#'
#' @importFrom ashr ash
#'
#' @export
init_prior.default <- function(Y,X, prior,v1 , indx_lst,lowc_wc )
{
  if( prior == "mixture_normal")
  {

    temp <- cal_Bhat_Shat(Y, X ,v1,lowc_wc )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function

    G_prior <- list()
    if( !is.null(lowc_wc)){
      G_prior[[1]]  <-  ash(c(temp$Bhat[,-lowc_wc]), c(temp$Shat[,-lowc_wc]),
                            mixcompdist ="normal",
                            outputlevel=0)
    }else {
      G_prior[[1]]  <-  ash(c(temp$Bhat ), c(temp$Shat ),
                            mixcompdist ="normal",
                            outputlevel=0)
    }

    attr(G_prior, "class")  <- "mixture_normal"
  }

  if( prior == "mixture_normal_per_scale")
  {

    temp <- cal_Bhat_Shat(Y, X, v1 ,lowc_wc )   ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function

    if( !is.null(lowc_wc)){
      t_ash <-   ash(c(temp$Bhat[,-lowc_wc]), c(temp$Shat[,-lowc_wc]),
                     mixcompdist ="normal",
                     outputlevel=0)
    }else {
      t_ash <-  ash(c(temp$Bhat ), c(temp$Shat ),
                    mixcompdist ="normal",
                    outputlevel=0)
    }

    G_prior  <- rep(list(t_ash),(log2(dim(Y)[2])+1))
    #first log2(Y_f)+1 element of G_prior   are ash prior fitted per level coefficient on var 1
    # element in  (log2(Y_f)+2):  2*( log2(Y_f)+1)   of G_prior   are ash prior fitted per level coefficient on var 2

    attr(G_prior, "class") <- "mixture_normal_per_scale"
  }

  return(G_prior)

}





#' @title Initialize the prior using sufficient satistics
#'
#' @description generate list of object corresponding to the parameters of the prior set for analysis
#'
#' @param data  an object of the class suff_stat define by function \code{\link{make_data_suff_stat}}
#'
#' @param prior Three choice are available "normal", "mixture_normal", "mixture_normal_per_scale"
#'
#' @param indx_lst list generated by \code{\link{gen_wavelet_indx}} for the given level of resolution, used only with class  mixture_normal_per_scale
#'
#' @return an object of the class "normal", "mixture_normal" or "mixture_normal_per_scale"
#'
#' @importFrom ashr ash
#'
#' @export
init_prior.suff_stat <- function(data, prior,  indx_lst )
{
  if( prior == "mixture_normal")
  {
    Bhat  <- data$Xty /diag(XtX)

    Shat  <- sqrt( 1 * matrix(1, ncol = ncol(Bhat), nrow= nrow(Bhat))/ diag(data$XtX))


    G_prior <- list()
    G_prior[[1]]  <-  ash(c(data$Bhat), c(data$Shat),mixcompdist ="normal")
    attr(G_prior, "class")  <- "mixture_normal"
  }

  if( prior == "mixture_normal_per_scale")
  {

     ## Speed Gain would be good to call directly cal_Bhat_Shat in the ash function
    G_prior  <-  lapply(1: (log2(dim(Y)[2])+1) ,
                        FUN= function(s) fit_ash_level(  Bhat=data$Bhat, data$Shat,s=s, indx_lst ) )
    #first log2(Y_f)+1 element of G_prior   are ash prior fitted per level coefficient on var 1
    # element in  (log2(Y_f)+2):  2*( log2(Y_f)+1)   of G_prior   are ash prior fitted per level coefficient on var 2

    attr(G_prior, "class") <- "mixture_normal_per_scale"
  }

  return(G_prior)

}






#' @title Get mixture proportion for mixture normal prior
#'
#' @description Get mixture proportion for mixture normal prior
#'
#' @param G_prior mixture normal prior
#'
#' @return vector of mixture proportion
#'
#' @export

get_pi_G_prior <- function(G_prior, ...)
  UseMethod("get_pi_G_prior")

#' @rdname get_pi_G_prior
#'
#' @method get_pi_G_prior mixture_normal
#'
#' @export get_pi_G_prior.mixture_normal
#'
#' @export
#'

get_pi_G_prior.mixture_normal <- function(G_prior, ...)
{
  out <- G_prior[[1]]$fitted_g$pi
  class(out)  <- "pi_mixture_normal"
  return(out)
}

#' @rdname get_pi_G_prior
#'
#' @method get_pi_G_prior mixture_normal_per_scale
#'
#' @export get_pi_G_prior.mixture_normal_per_scale
#'
#' @export
#'
get_pi_G_prior.mixture_normal_per_scale <- function(G_prior, ...)
{
  out <- lapply(G_prior, function(x) x$fitted_g$pi)
  class(out) <- "pi_mixture_normal_per_scale"
  return(out)
}


#'@title Get mixture proportion for mixture normal prior per scale
#'
#'@description Add description here.
#'@param G_prior mixture normal prior
#'@return list of vector of mixture proportion
#'@export


get_pi0 <- function(G_prior, ...)
  UseMethod("get_pi0")


#' @rdname get_pi0
#'
#' @method get_pi0 mixture_normal
#'
#' @export get_pi0.mixture_normal
#'
#' @export
#'
get_pi0.mixture_normal <- function(G_prior, ...)
{
  out <- get_pi_G_prior(G_prior)[1]
  return(out)
}

#' @rdname get_pi0
#'
#' @method get_pi0 mixture_normal_per_scale
#'
#' @export get_pi0.mixture_normal_per_scale
#'
#' @export
#'
get_pi0.mixture_normal_per_scale <- function(G_prior, ...)
{
  pi_prior_list <- get_pi_G_prior(G_prior)
  out <-  lapply(pi_prior_list, function(x){unlist( lapply(x, function(y) y[1])) } )
  return(out)
}




#' @title Get mixture proportion for mixture normal prior
#'
#' @description Add description here.
#'
#' @param tpi  object of class pi_mixture_normal
#'
#' @return numeric between 0 an 1
#'
#' @export
#'


get_pi0 <- function(tpi, ...)
  UseMethod("get_pi0")


#' @rdname get_pi0
#'
#' @method get_pi0 pi_mixture_normal
#'
#' @export get_pi0.pi_mixture_normal
#'
#' @export
#'
get_pi0.pi_mixture_normal  <- function(tpi, ...)
{
  out <- tpi[1]
  return(out)
}




#' @rdname get_pi0
#'
#' @method get_pi0 pi_mixture_normal_per_scale
#'
#' @export get_pi0.pi_mixture_normal_per_scale
#'
#' @export
#'
get_pi0.pi_mixture_normal_per_scale  <- function(tpi, ...)
{
  out <-    (unlist(lapply(tpi, function(y) y[[1]][1]) ))
  return(out)
}


#' @title Get mixture standard deviations for mixture normal prior
#'
#' @description Add description here.
#'
#' @param G_prior mixture normal prior
#'
#' @return vector of standard deviations
#'
#' @export
#'

get_sd_G_prior <- function(G_prior , ...)
  UseMethod("get_sd_G_prior")


#' @rdname get_sd_G_prior
#'
#' @method get_sd_G_prior mixture_normal
#'
#' @export get_sd_G_prior.mixture_normal
#'
#' @export
#'
get_sd_G_prior.mixture_normal <- function(G_prior, ...)
{
  out <- G_prior[[1]]$fitted_g$sd
  class(out) <- "sd_mixture_normal"
  return(out)
}



#' @rdname get_sd_G_prior
#'
#' @method get_sd_G_prior mixture_normal_per_scale
#'
#' @export get_sd_G_prior.mixture_normal_per_scale
#'
#' @export
#'
get_sd_G_prior.mixture_normal_per_scale <- function(G_prior, ...)
{
  out <- lapply(G_prior, function(x) x$fitted_g$sd)
  class(out) <- "sd_mixture_normal_per_scale"
  return(out)
}





#' @title Update mixture proportion for mixture normal prior
#'
#' @description Add description here.
#'
#' @param G_prior a prior of class "mixture_normal" or a prior of class "mixture_normal_per_scale"
#'
#' @param tpi a vector of proportion of class "pi_mixture_normal" resp "pi_mixture_normal_per_scale"
#'
#' @return a prior of class "mixture_normal" or a prior of class "mixture_normal_per_scale"
#'
#' @export
#'
#'

update_prior <- function(G_prior, tpi, ...)
  UseMethod("update_prior")


#' @rdname update_prior
#'
#' @method update_prior mixture_normal
#'
#' @export update_prior.mixture_normal
#'
#' @export
#'
update_prior.mixture_normal <- function(G_prior, tpi, ...)
{
  if( class(tpi)[1]=="pi_mixture_normal"){
   G_prior[[1]]$fitted_g$pi <- tpi
  }else{
    stop("Error: tpi is not of class pi_mixture_normal,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(G_prior)
}


#' @rdname update_prior
#'
#' @method update_prior mixture_normal_per_scale
#'
#' @export update_prior.mixture_normal_per_scale
#'
#' @export
#'

update_prior.mixture_normal_per_scale <- function(G_prior, tpi, ...)
{
  if( class(tpi)[1]=="pi_mixture_normal_per_scale"){
    out <- mapply(update_ash_pi ,G_prior, tpi, SIMPLIFY = FALSE)
    class(out ) <- "mixture_normal_per_scale"
  }else{
    stop("Error: tpi is not of class pi_mixture_normal_per_scale,\n please compute tpi using generic functions m_step or get_pi_G_prior")
  }

  return(out)
}

#' @title Update ash object mixture proportion
#'
#' @description  Update ash object mixture proportion
#'
#' @param G a ash object
#'
#' @param tpi a vector of proportion
#'
#' @return an ash object with updated mixture proportion
#'
#' @export
update_ash_pi<- function(G , tpi)
{

  if( length(G$fitted_g$pi )==length(tpi))
  {
    G$fitted_g$pi <- tpi
  }else{
    stop("Error: when updating ash object length of new mixture proportion
    \nlonger than the mixture proportion in the ash object    ")

  }

  return(G)
}

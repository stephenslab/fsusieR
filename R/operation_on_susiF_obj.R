################################## Operations on susiF object ############################


#' @title Compute partial residual for effect l
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
#' @param X matrix of covariates
#
#' @param D matrix of wavelet D coefficients from the original input data (Y)
#
#' @param C vector of wavelet scaling coefficient from the original input data (Y)
#
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
#' @return a matrix of size N by size J of partial residuals
#
#' @export
#' @keywords internal
cal_partial_resid  <- function( susiF.obj, l, X, D, C,  indx_lst,... )
  UseMethod("cal_partial_resid")


#' @rdname cal_partial_resid
#
#' @method cal_partial_resid susiF
#
#' @export cal_partial_resid.susiF
#
#' @export
#' @keywords internal

cal_partial_resid.susiF  <- function( susiF.obj, l, X, D, C,  indx_lst,... )
{
  L <- susiF.obj$L
  if (L > 1){
    id_L <- (1:L)[ - ( (l%%L) +1) ]#Computing residuals R_{l+1} by removing all the effect except effect l+1

    if(inherits(get_G_prior(susiF.obj),"mixture_normal_per_scale" ))
    {
      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) X%*%sweep(susiF.obj$fitted_wc[[l]][,-indx_lst[[length(indx_lst)]]],
                                                                          1,
                                                                          susiF.obj$alpha[[l]],
                                                                          "*"
                                                                          )
                                              )
                                )
      update_C  <-  C  - Reduce("+", lapply  ( id_L, function(l) X%*%(susiF.obj$fitted_wc[[l]][,indx_lst[[length(indx_lst)]]]*susiF.obj$alpha[[l]]
                                                                          )
                                               )
                                )
      update_Y  <- cbind(  update_D, update_C)

    }
    if(inherits(get_G_prior(susiF.obj),"mixture_normal" ))
    {




      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) X%*%sweep(susiF.obj$fitted_wc[[l]][,-dim(susiF.obj$fitted_wc[[l]])[2]],
                                                                          1,
                                                                          susiF.obj$alpha[[l]],
                                                                          "*"
                                                                          )
                                              )
                              )
      update_C  <-  C  - Reduce("+", lapply  ( id_L, function(l) X%*%(susiF.obj$fitted_wc[[l]][,dim(susiF.obj$fitted_wc[[l]])[2]]*susiF.obj$alpha[[l]]

                                                                          )
                                              )
                                )

          update_Y  <- cbind(  update_D, update_C)
    }
  }else{
    id_L <- 1

    if(inherits(get_G_prior(susiF.obj),"mixture_normal_per_scale" ))
    {
      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) X%*%sweep(susiF.obj$fitted_wc[[l]][,-indx_lst[[length(indx_lst)]]],
                                                                          1,
                                                                          susiF.obj$alpha[[l]],
                                                                          "*"
                                                                        )
                                            )
                                )
        update_C  <-  C  - Reduce("+", lapply  ( id_L, function(l) X%*%(susiF.obj$fitted_wc[[l]][,indx_lst[[length(indx_lst)]]]*susiF.obj$alpha[[l]]
                                                                         )
                                            )
                               )

      update_Y  <- cbind(  update_D, update_C)
    }
    if(inherits(get_G_prior(susiF.obj),"mixture_normal" ))
    {




      update_D  <-  D - Reduce("+", lapply  ( id_L, function(l) X%*%sweep(susiF.obj$fitted_wc[[l]][,-dim(susiF.obj$fitted_wc[[l]])[2]],
                                                                          1,
                                                                          susiF.obj$alpha[[l]],
                                                                          "*"
                                                                   )
                                           )
                               )
      update_C  <-  C  - Reduce("+", lapply  ( id_L, function(l) X%*%(susiF.obj$fitted_wc[[l]][,dim(susiF.obj$fitted_wc[[l]])[2]]*susiF.obj$alpha[[l]]

                                               )
                                        )
                                )

      update_Y  <- cbind(  update_D, update_C)
    }
  }


  return(update_Y)
}

#' @title Check purity credible sets
#
#' @param susiF.obj a susif object defined by init_susiF_obj function
#' @param min.purity minimal purity within a CS
#' @param X matrix of covariates
#
#' @return a susif.obj without "dummy" credible s
#
#' @export
#' @keywords internal

check_cs <- function(susiF.obj, min.purity=0.5,X,...)
  UseMethod("check_cs")

#' @rdname check_cs
#
#' @method check_cs susiF
#
#' @export check_cs.susiF
#
#' @export
#' @keywords internal


check_cs.susiF <- function(susiF.obj, min.purity=0.5,X,  ...)
{
  dummy.cs <- which_dummy_cs(susiF.obj, min.purity=min.purity,X)

    if( length(dummy.cs)==0)
    {
      return(susiF.obj)
    }else{
      if(length(dummy.cs)==susiF.obj$L) #avoid returning empty results
      {
        dummy.cs <- dummy.cs[-length(dummy.cs)]
      }
      susiF.obj <- discard_cs( susiF.obj,cs=dummy.cs, out_prep= TRUE)
      return(susiF.obj)
    }


}


#' @title Discard credible sets
#
#' @param susiF.obj a susif object defined by init_susiF_obj function
#
#' @param cs vector of integer containing the credible sets to discard
#
#' @param out_prep logical, if set to true perform cleaning for final output
#
#' @return a susif.obj without "dummy" credible sets
#
#' @export
#' @keywords internal

discard_cs <- function(susiF.obj, cs,out_prep,...)
  UseMethod("discard_cs")

#' @rdname discard_cs
#
#' @method discard_cs susiF
#
#' @export discard_cs.susiF
#
#' @export
#' @keywords internal

discard_cs.susiF <- function(susiF.obj, cs, out_prep=FALSE,  ...)
{
    if( length(cs)==susiF.obj$L){
        cs <- cs[-1]
        if(length(cs)==0){
          return(susiF.obj)
        }
      }
  susiF.obj$alpha       <-  susiF.obj$alpha[ -cs]
  susiF.obj$lBF         <-  susiF.obj$lBF[ -cs]
  susiF.obj$fitted_wc   <-  susiF.obj$fitted_wc[ -cs]
  susiF.obj$fitted_wc2  <-  susiF.obj$fitted_wc2[ -cs]
  susiF.obj$cs          <-  susiF.obj$cs[ -cs]
  if(out_prep){
    susiF.obj$fitted_func <-  susiF.obj$fitted_func[ -cs]
  }else{
    susiF.obj$greedy_backfit_update <- TRUE
    susiF.obj$KL                    <- susiF.obj$KL[ -cs]
    susiF.obj$ELBO                  <- -Inf
  }

  susiF.obj$est_sd      <-  susiF.obj$est_sd[ -cs]
  susiF.obj$est_pi      <-  susiF.obj$est_pi[ -cs]
  susiF.obj$cred_band   <-  susiF.obj$cred_band[ -cs]
  #susiF.obj$lfsr_wc     <-  susiF.obj$lfsr_wc [ -cs]
  susiF.obj$L           <-  susiF.obj$L -length(cs)
  return(susiF.obj)
}

#' @title Update residual variance
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param Y wavelet transformed  functional phenotype, matrix of size N by size J.
#
#' @param X matrix of size N by p
#
#
#' @return estimated residual variance
#
#' @export
#' @keywords internal
estimate_residual_variance <- function(susiF.obj,Y,X,... )
  UseMethod("estimate_residual_variance")

#' @rdname estimate_residual_variance
#
#' @method estimate_residual_variance susiF
#
#' @export estimate_residual_variance.susiF
#
#' @export
#
estimate_residual_variance.susiF <- function(susiF.obj,Y,X,... )
{
  out <-  (1/(prod(dim(Y))))*get_ER2 (susiF.obj,Y, X  )
  return(out)
}

# @title Expand susiF.obj by adding L_extra effect
#
# @param susiF.obj a susiF.obj
#
# @param L_extra numeric a number of effect to add
#
# @return a susiF.obj a L_extra effect. Note the the number of effect of the susiF.obj cannot exceed the number the user upper bound
# @export
expand_susiF_obj <- function(susiF.obj,L_extra)
{
  L_extra <- ifelse ( max(susiF.obj$L_max - susiF.obj$L+L_extra,0 ) >0,#check if we are adding more effect that maximum specified by user
                      L_extra,
                      abs(susiF.obj$L_max - susiF.obj$L+L_extra)
                      )
  if( L_extra==0){
    return(susiF.obj)
  }else{
    L_old <- susiF.obj$L
    L_new <- susiF.obj$L+L_extra
    susiF.obj$L <- ifelse(L_new<(susiF.obj$P+1),L_new,P)

    for ( l in (L_old+1):susiF.obj$L )
    {
      susiF.obj$fitted_wc[[l]]        <-  0*susiF.obj$fitted_wc[[1]]
      susiF.obj$fitted_wc2[[l]]       <-  0*susiF.obj$fitted_wc2[[1]] +1
      susiF.obj$alpha [[l]]           <-  rep(0, length(susiF.obj$alpha [[1]]))
      susiF.obj$cs[[l]]               <-  list()
      susiF.obj$est_pi [[l]]          <-  susiF.obj$est_pi[[1]]
      susiF.obj$est_sd [[l]]          <-  susiF.obj$est_sd[[1]]
      susiF.obj$lBF[[l]]              <-  rep(NA, length( susiF.obj$lBF[[1]]))
      susiF.obj$cred_band[[l]]        <- matrix(0, ncol = ncol(susiF.obj$cred_band[[1]] ), nrow = 2)
      susiF.obj$KL                    <- rep(NA,susiF.obj$L)
      susiF.obj$ELBO                  <- c()
    }
    susiF.obj$n_expand <- susiF.obj$n_expand+1
    susiF.obj$greedy_backfit_update <- TRUE
    return(susiF.obj)
  }

}
#' @title Access fitted effect l
#' @param  susiF.obj a fitted objected
#' @param l effect of interest
#' @param \dots Other arguments.
#' @export
get_fitted_effect <- function(susiF.obj,l,... )
  UseMethod("get_fitted_effect")


#' @rdname get_fitted_effect
#
#' @method get_fitted_effect susiF
#
#' @export get_fitted_effect.susiF
#
#' @export
#
get_fitted_effect.susiF <- function(susiF.obj, l, ...){
  return( unlist(susiF.obj$fitted_func[[l]]))
}

#
# @title Access susiF mixture proportion of effect l
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
# @return a vector of  proportion
#
# @export
#
get_pi  <- function(susiF.obj, l,...)
  UseMethod("get_pi")

# @rdname get_pi
#
# @method get_pi susiF
#
# @export get_pi.susiF
#
# @export
#
get_pi.susiF <- function(susiF.obj, l,...)
{

  if( l >  length(susiF.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  out <- susiF.obj$est_pi[[l]]
  return(out)
}





# @title Access susiF log Bayes factors of effect l
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
# @return a vector of log Bayes Factors
#
# @export
#
get_lBF  <- function(susiF.obj, l,...)
  UseMethod("get_lBF")

# @rdname get_pi
#
# @method get_pi susiF
#
# @export get_pi.susiF
#
# @export
#
get_lBF.susiF <- function(susiF.obj, l,...)
{

  if( l >   susiF.obj$L)
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  out <- susiF.obj$lBF[[l]]
  return(out)
}










#' @title Compute Epected sum of square
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param Y wavelet transformed  functional phenotype, matrix of size N by size J.
#
#' @param X matrix of size N by p
#
#
#' @return estimated residual variance
#' @export
get_ER2 <- function(susiF.obj,Y,X,... )
  UseMethod("get_ER2")


#' @rdname get_ER2
#
#' @method get_ER2 susiF
#
#' @export get_ER2.susiF
#
#' @export
#' @keywords internal

get_ER2.susiF = function (  susiF.obj,Y, X,  ...) {
  postF <- get_post_F(susiF.obj )# J by N matrix
  #Xr_L = t(X%*% postF)
  postF2 <- get_post_F2(susiF.obj ) # Posterior second moment.

  return(sum(t((Y - X%*%postF ))%*%(Y - X%*%postF ) )  -sum(t(postF)%*%postF) + sum(    postF2))
}



#
#' @title Access susiF internal prior
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @return G_prior object
#
#' @export
#' @keywords internal
#
get_G_prior  <- function(susiF.obj,...)
  UseMethod("get_G_prior")



#' @rdname get_G_prior
#
#' @method get_G_prior susiF
#
#' @export get_G_prior.susiF
#
#' @export
#' @keywords internal
get_G_prior.susiF <- function(susiF.obj,...)
{
  out <- susiF.obj$G_prior
  return(out)
}





# @title Compute posterior mean of the fitted effect
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param l , optional effect to update
#
# @return  A J by T matrix of posterior wavelet coefficient,
# \item{if l  missing}{return sum of the  effect  posterior mean }
# \item{if l not missing}{return effect specific posterior mean}
get_post_F <- function(susiF.obj,l,...)
  UseMethod("get_post_F")

# @rdname get_post_F
#
# @method get_post_F susiF
#
# @export get_post_F.susiF
#
# @export
#

get_post_F.susiF <- function(susiF.obj,l,...)
{
  if(missing(l))
  {
    out <-  Reduce("+",lapply(1:susiF.obj$L, FUN=function(l) susiF.obj$alpha[[l]] * susiF.obj$fitted_wc[[l]]))
  }else{
    out <-   susiF.obj$alpha[[l]] * susiF.obj$fitted_wc[[l]]
  }

  return(out)
}



# @title Compute posterior second moment
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
# @param l , optional effect to update
#
# @return  A J by T matrix of posterior wavelet coefficient,
# \item{if l  missing}{return sum of the effects  posterior second moment }
# \item{if l not missing}{return effect specific posterior second moment}

get_post_F2 <- function(susiF.obj,l,...)
  UseMethod("get_post_F2")

# @rdname get_post_F2
#
# @method get_post_F2 susiF
#
# @export get_post_F2.susiF
#
# @export
#
get_post_F2.susiF <- function(susiF.obj, l,...)
{
  if(missing(l))
  {
    out <-  Reduce("+",lapply(1:susiF.obj$L, FUN=function(l) susiF.obj$alpha[[l]] *(susiF.obj$fitted_wc2[[l]]+ susiF.obj$fitted_wc [[l]]^2)))
  }else{
    out <-   susiF.obj$alpha[[l]] *( susiF.obj$fitted_wc2[[l]]+ susiF.obj$fitted_wc[[l]]^2)
  }

  return(out)
}



# @title Update alpha  susiF mixture proportion of effect l
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
#
# @return susiF object
#
# @export
#
#
get_alpha  <-  function(susiF.obj, l,...  )
  UseMethod("get_alpha")

# @rdname get_alpha
#
# @method get_alpha susiF
#
# @export get_alpha.susiF
#
# @export
#

get_alpha.susiF <-  function(susiF.obj, l,...  )
{
  out <- susiF.obj$alpha[[l]]
  return( out)
}

#' @title Update  susiF via greedy search or backfit
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#' @param X matrix of size n by p contains the covariates
#' @param min.purity minimum purity for estimated credible sets
#' @param verbose If \code{verbose = TRUE}, the algorithm's progress,
# and a summary of the optimization settings, are printed to the
# console.
#' @param cov_lev the desired level of converage
#' @return susiF object
#
#' @export
#' @keywords internal
#
#
greedy_backfit  <-  function(susiF.obj,
                             verbose,
                             cov_lev,
                             X,
                             min.purity,...  )
  UseMethod("greedy_backfit")

#' @rdname greedy_backfit
#
#' @method greedy_backfit susiF
#
#' @export greedy_backfit.susiF
#
#' @export
#' @keywords internal
greedy_backfit.susiF <-  function(susiF.obj,
                                  verbose,
                                  cov_lev,
                                  X,
                                  min.purity,...  )
{


  susiF.obj <- update_alpha_hist(susiF.obj)
  if(!(susiF.obj$greedy)&!(susiF.obj$backfit))
  {
    return(susiF.obj)
  }
  susiF.obj <- update_cal_cs(susiF.obj,
                             cov_lev=cov_lev)


  dummy.cs <-  which_dummy_cs(susiF.obj,
                              min.purity = min.purity,
                              X=X)


  if(susiF.obj$backfit & (length(dummy.cs)>0)){

    susiF.obj$greedy <- FALSE
    if(length(dummy.cs)== susiF.obj$L){
      dummy.cs <- dummy.cs[-1]
      susiF.obj$backfit <- FALSE
    }
    if( length(dummy.cs)==0  )
    {
      susiF.obj$backfit <- FALSE
    }else{
      temp_L <- susiF.obj$L


      susiF.obj <- discard_cs(susiF.obj,
                              cs= dummy.cs,
                              out_prep= FALSE
      )

      if( length(susiF.obj$cs)>1){
        A <- cal_cor_cs(susiF.obj, X)$cs_cor
        tl <- which(A>0.99, arr.ind = TRUE)
        tl <-  tl[- which( tl[,1]==tl[,2]),]

        if ( dim(tl)[1]==0){

        }else{

          tl <-  tl[which(tl[,1] < tl[,2]),]
          susiF.obj <- merge_effect(susiF.obj, tl)

        }
      }
      if(verbose){
        print( paste( "Discarding ",(temp_L- susiF.obj$L), " effects"))
      }
    }
    return(susiF.obj)

  }##Conditions for stopping greedy search
  if(  (susiF.obj$L>susiF.obj$L_max))
  {

    susiF.obj$greedy <- FALSE



    susiF.obj <- discard_cs(susiF.obj,
                            cs= (susiF.obj$L_max+1):susiF.obj$L,
                            out_prep= FALSE
    )




    if( length(susiF.obj$cs)>1){
      A <- cal_cor_cs(susiF.obj, X)$cs_cor
      tl <- which(A>0.99, arr.ind = TRUE)
      tl <-  tl[- which( tl[,1]==tl[,2]),]

      if ( dim(tl)[1]==0){

      }else{

        tl <-  tl[which(tl[,1] < tl[,2]),]
        susiF.obj <- merge_effect(susiF.obj, tl)

      }
    }
    if(verbose){
      print( paste( "Discarding ",(susiF.obj$L_max- susiF.obj$L), " effects"))
      print( "Greedy search and backfitting done")
    }

  }

  if( length(dummy.cs)==0& !( susiF.obj$greedy))
  {
    susiF.obj$backfit <- FALSE
  }

  if(!(susiF.obj$greedy )&!(susiF.obj$backfit ) ){

    if( length(susiF.obj$cs)>1){
      A <- cal_cor_cs(susiF.obj, X)$cs_cor
      tl <- which(A>0.99, arr.ind = TRUE)
      tl <-  tl[- which( tl[,1]==tl[,2]),]

      if ( dim(tl)[1]==0){

      }else{

        tl <-  tl[which(tl[,1] < tl[,2]),]
        susiF.obj <- merge_effect(susiF.obj, tl)

      }
    }

    if(verbose){
      print( paste( "Discarding ",(susiF.obj$L_max- susiF.obj$L), " effects"))
     print( "Greedy search and backfitting done")
    }
    susiF.obj <- update_alpha_hist(susiF.obj,discard = TRUE)
    susiF.obj$greedy_backfit_update <- FALSE

    return(susiF.obj)
  }
  if(susiF.obj$greedy & (length(dummy.cs)==0)){

    tt <- susiF.obj$L_max -susiF.obj$L
    temp <- min( ifelse(tt>0,tt,0 ) , 7)

    if(temp==0){
      if( length(susiF.obj$cs)>1){
        A <- cal_cor_cs(susiF.obj, X)$cs_cor
        tl <- which(A>0.99, arr.ind = TRUE)
        tl <-  tl[- which( tl[,1]==tl[,2]),]

        if ( dim(tl)[1]==0){

        }else{

          tl <-  tl[which(tl[,1] < tl[,2]),]
          susiF.obj <- merge_effect(susiF.obj, tl)

        }
      }

      if(verbose){
        print( paste( "Discarding ",(susiF.obj$L_max- susiF.obj$L), " effects"))
        print( "Greedy search and backfitting done")
      }
      susiF.obj <- update_alpha_hist(susiF.obj,discard = TRUE)
      susiF.obj$greedy_backfit_update <- FALSE
      susiF.obj$backfit <- FALSE
      susiF.obj$greedy <- FALSE
      return(susiF.obj)
    }


    if(verbose){
      print( paste( "Adding ", temp, " extra effects"))
    }



    if( length(susiF.obj$cs)>1){
      A <- cal_cor_cs(susiF.obj, X)$cs_cor
      tl <- which(A>0.99, arr.ind = TRUE)
      tl <-  tl[- which( tl[,1]==tl[,2]),]

      if ( dim(tl)[1]==0){

      }else{

        tl <-  tl[which(tl[,1] < tl[,2]),]
        susiF.obj <- merge_effect(susiF.obj, tl, discard=FALSE)

      }
    }




    susiF.obj <- expand_susiF_obj(susiF.obj,L_extra = temp)
    return(susiF.obj)
  }

}




# @title Initialize a susiF object using regression coefficients
#
# @param L_max upper bound on the number of non zero coefficients An L-vector containing the indices of the
#   nonzero coefficients.
#
# @param G_prior prior object defined by init_prior function
#
# @param Y Matrix of outcomes
#
# @param X matrix of covariatess
#
# @param L_start number of effect to start with
#
# @param greedy logical, if TRUE allow greedy search
#
# @param backfit logical, if TRUE allow backfitting
#
# @export
# @return A list with the following elements
# \item{fitted_wc}{ list of length L, each element contains the fitted wavelet coefficients of effect l}
# \item{fitted_wc2}{list of length L, each element contains the variance of the fitted wavelet coefficients of effect l}
# \item{alpha_hist}{ history of the fitted alpha value}
# \item{N}{ number of indidivual in the study}
# \item{sigma2}{residual variance}
# \item{n_wac}{number of wavelet coefficients}
# \item{ind_fitted_func}{fitted curves of each individual }
# \item{cs}{credible set}
# \item{pip}{Posterior inclusion probabilites}
# \item{G_prior}{a G_prior of the same class as the input G_prior, used for internal calculation}
# \item{lBF}{ log Bayes factor for the different effect}
# \item{KL}{ the KL divergence for the different effect}
# \item{ELBO}{ The evidence lower bound}
# \item{lfsr_wc}{Local fasle sign rate of the fitted wavelet coefficients}
# @export
#
init_susiF_obj <- function(L_max, G_prior, Y,X,L_start,greedy,backfit,... )
{



  fitted_wc       <- list()
  fitted_wc2      <- list()
  alpha           <- list()
  alpha_hist      <- list()
  ind_fitted_func <- matrix(0, nrow = dim(Y)[1], ncol=dim(Y)[2]  )
  cs              <- list()
  cred_band       <- list()
  pip             <- rep(0, dim(X)[2])
  est_pi          <- list()
  est_sd          <- list()
  L_max           <- L_max
  L               <- L_start
  G_prior         <- G_prior
  N               <- dim(Y)[1]
  n_wac           <- dim(Y)[2]
  P               <- dim(X)[2]
  sigma2          <- 1
  lBF             <- list()
  KL              <- rep(NA,L)
  ELBO            <- c()
  mean_X          <- attr(X, "scaled:center")
  csd_X           <- attr(X, "scaled:scale")
  n_expand        <- 0 #number of greedy expansion
  greedy          <- greedy
  backfit         <- backfit
  greedy_backfit_update <- FALSE
  for ( l in 1:L )
  {
    fitted_wc[[l]]        <-  matrix(0, nrow = dim(X)[2], ncol=dim(Y)[2]  )
    fitted_wc2[[l]]       <-  matrix(1, nrow = dim(X)[2], ncol=dim(Y)[2]  )
    alpha [[l]]           <-  rep(1/dim(X)[2], dim(X)[2])
    cs[[l]]               <-  list()
    est_pi [[l]]          <-  get_pi_G_prior(G_prior)
    est_sd [[l]]          <-  get_sd_G_prior(G_prior)
    lBF[[l]]              <-  rep(NA, ncol(X))
    cred_band[[l]]        <-  matrix(0, ncol = dim(Y)[2], nrow = 2)
  }
  obj <- list( fitted_wc       = fitted_wc,
               fitted_wc2      = fitted_wc2,
               lBF             = lBF,
               KL              = KL,
               cred_band       = cred_band,
               ELBO            = ELBO,
               ind_fitted_func = ind_fitted_func,
               G_prior         = G_prior,
               alpha_hist      = alpha_hist,
               N               = N,
               n_wac           = n_wac,
               sigma2          = sigma2,
               P               = P,
               alpha           = alpha,
               cs              = cs,
               pip             = pip,
               est_pi          = est_pi,
               est_sd          = est_sd,
               L               = L,
               L_max           = L_max,
               csd_X           = csd_X,
               n_expand        = n_expand,
               greedy          = greedy,
               backfit         = backfit,
               greedy_backfit_update=greedy_backfit_update)

  class(obj) <- "susiF"
  return(obj)
}



#' @title Merging effect function
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param tl see  \code{\link{greedy_backfit}}
#
#' @param discard logical, if set to TRUE allow discarding redundant effect
#
#
#
#' @return  a susiF object
#' @export
#' @keywords internal
merge_effect <- function( susiF.obj, tl,...)
  UseMethod("merge_effect")

#' @rdname merge_effect
#
#' @method merge_effect susiF
#
#' @export merge_effect.susiF
#
#' @export
#' @keywords internal

merge_effect.susiF <- function( susiF.obj, tl, discard=TRUE,  ...){




  if(is.vector( tl)){
    #print( tl)
    susiF.obj$fitted_wc[[tl[  2]]] <- 0* susiF.obj$fitted_wc[[tl[ 2]]]
    susiF.obj$fitted_wc[[tl[  1]]] <- susiF.obj$fitted_wc[[tl[  1]]] +   susiF.obj$fitted_wc[[tl[ 2]]]
    susiF.obj$fitted_wc2[[tl[ 1]]] <- susiF.obj$fitted_wc2[[tl[  1]]] +   susiF.obj$fitted_wc2[[tl[  2]]]
    tindx <-  tl[  2]
  }else{
    tl <- tl[order(tl[,1], tl[,2], decreasing = TRUE),]
    #print( tl)
    tindx <- c(0)
    for ( o in 1:dim(tl)[1]){

      if ( tl[o, 2]%!in%tindx){
        susiF.obj$fitted_wc[[tl[o, 2]]] <- 0* susiF.obj$fitted_wc[[tl[o, 2]]]
        susiF.obj$fitted_wc[[tl[o, 1]]] <-susiF.obj$fitted_wc[[tl[o, 1]]] +   susiF.obj$fitted_wc[[tl[o, 2]]]
        susiF.obj$fitted_wc2[[tl[o, 1]]] <-susiF.obj$fitted_wc2[[tl[o, 1]]] +   susiF.obj$fitted_wc2[[tl[o, 2]]]
        tindx <- c(tindx, tl[o, 2])
      }

    }

    tindx <- tindx[-1]

  }
  if(discard){
   susiF.obj<-  discard_cs(susiF.obj,cs=tindx, out_prep=FALSE)
  }

  return( susiF.obj)
}



# @title Updates CS names for output
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param X matrix of size N by p

name_cs <- function(susiF.obj,X,...)
  UseMethod("name_cs")

# @rdname name_cs
#
# @method name_cs susiF
#
# @export name_cs.susiF
#
# @export
#

name_cs.susiF <- function(susiF.obj,X,...){

  if( length(colnames(X))==ncol(X)){

    for (l in 1: length(susiF.obj$cs)){
      names(susiF.obj$cs[[l]]) <- colnames(X)[susiF.obj$cs[[l]]]
    }

  }
  return(susiF.obj)
}


#' @title Preparing output of main susiF function
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param Y functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelets that assume that J is of the form J^2. If J is not a power of 2, susiF internally remaps the data into a grid of length 2^J
#
#' @param X matrix of size N by p
#
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
#' @param filter.cs logical, if TRUE filter the credible set (removing low purity cs and cs with estimated prior equal to 0)
#
#' @param lfsr_curve Maximum local false sign rate of the wavelet coefficients used to reconstruct lfsr_curves (see output)
#' @param outing_grid grid use to fit fsusie
#' @return susiF object
#
#' @export
#' @keywords internal
out_prep <- function(susiF.obj,Y, X, indx_lst, filter.cs, lfsr_curve,outing_grid,...)
  UseMethod("out_prep")

#' @rdname out_prep
#
#' @method out_prep susiF
#
#' @export out_prep.susiF
#
#' @export
#' @keywords internal

out_prep.susiF <- function(susiF.obj,Y, X, indx_lst, filter.cs, lfsr_curve, outing_grid,...)
{

  susiF.obj <-  update_cal_pip(susiF.obj)
  susiF.obj <-  update_cal_fit_func(susiF.obj, indx_lst)
  susiF.obj <-  update_cal_credible_band(susiF.obj, indx_lst)
  susiF.obj <-  name_cs(susiF.obj,X)
  if(filter.cs)
  {
    susiF.obj <- check_cs(susiF.obj,min.purity=0.5,X=X)
  }
  susiF.obj <-  update_cal_indf(susiF.obj, Y, X, indx_lst)

  susiF.obj$outing_grid <- outing_grid
  return(susiF.obj)
}





#' @title Plot susiF object
#
#' @param susiF.obj output of the susiF function
#
#' @param cred.band logical if set as true plot credible bands. Set as TRUE by default
#' @param effect numerical if specified plot on effect in particular
#' @param size_line numeric, width of the plotted lines
#' @param size_point numeric, size of the point
#' @param pos_SNP vector containing the base pair of the SNPs
#' @param point_shape vector containing the shape of dots
#' @param start_end_region start end of the region
#' @param pip_only logical, if TRUE only ouput the PIP plot
#' @param title character
#' @param \dots Other arguments..
#' @importFrom ggplot2 ggplot
#' @importFrom ggplot2 aes_string
#' @importFrom ggplot2 geom_line
#' @importFrom ggplot2 facet_wrap
#' @importFrom ggplot2 facet_grid
#' @importFrom ggplot2 geom_point
#' @importFrom ggplot2 geom_hline
#' @importFrom ggplot2 theme
#' @importFrom ggplot2 element_blank
#' @importFrom ggplot2 scale_color_manual
#' @importFrom ggplot2 xlab
#' @importFrom ggplot2 ylab
#' @importFrom ggplot2 geom_ribbon
#' @importFrom ggplot2 scale_fill_manual
#
#' @export
#
plot_susiF  = function (susiF.obj, title="",
                        cred.band = FALSE,
                        effect,
                        size_line=2,
                        size_point=4,
                        pos_SNP,
                        start_end_region=c(0,1),
                        pip_only=FALSE,
                        point_shape, ...)
{

  if(missing(pos_SNP)){
    pos_SNP<-  1:length(susiF.obj$pip)
  }
  if( missing(point_shape)){
    point_shape <- rep( 19, length(pos_SNP))
  }
  color = c("black", "dodgerblue2", "green4", "#6A3D9A", "#FF7F00",
            "gold1", "skyblue2", "#FB9A99", "palegreen2", "#CAB2D6",
            "#FDBF6F", "gray70", "khaki2", "maroon", "orchid1", "deeppink1",
            "blue1", "steelblue4", "darkturquoise", "green1", "yellow4",
            "yellow3", "darkorange4", "brown")
  L <- susiF.obj$L
  n_wac <- susiF.obj$n_wac
  y <- susiF.obj$pip
  col_y <- rep(0, length(y))
  if (missing(effect)) {
    for (l in 1:L) {
      col_y[which(1:length(y) %in% susiF.obj$cs[[l]])] <- l
    }
    df <- data.frame(y = y, CS = as.factor(col_y))%>%
      dplyr::mutate(CS = factor(CS, levels = 0:L, labels = c("Not in CS", 1:L)))



    P1 <- ggplot(df, aes_string(y = "y", x = "pos_SNP",col = "CS")) +
      geom_point(size = size_point,shape=point_shape) +
      theme(axis.ticks.x = element_blank(),axis.text.x = element_blank()) +
      scale_color_manual("Credible set",values = color) +
      xlab("SNP index") + ylab("Posterior Inclusion Probability (PIP)")
    fun_plot <- do.call(c, susiF.obj$fitted_func)
    fun_plot <- c(rep(0, n_wac), fun_plot)

    if(pip_only){
      return(P1)
    }
    if (cred.band) {
      cred_band <- data.frame(t(do.call(cbind, susiF.obj$cred_band)))
      cred_band <- rbind(data.frame(up = rep(0, n_wac),
                                    low = rep(0, n_wac)), cred_band)
      x <- rep(1:susiF.obj$n_wac, (susiF.obj$L + 1))
      CS <- rep(0:L, each = n_wac)
      df <- data.frame(fun_plot = fun_plot, CS = as.factor(CS),
                       x = x, upr = cred_band$up, lwr = cred_band$low)
      P2 <- ggplot(df, aes_string(y = fun_plot, x = x, col = CS)) +
       geom_line(size = size_line) +
           geom_ribbon(aes_string(ymin = "lwr",ymax = "upr",fill = "CS",
                                  col = "CS"),alpha = 0.3) +
        scale_color_manual("Credible set", values = color) +
        scale_fill_manual("Credible set", values = color) +
        facet_grid(CS~.) +
        xlab("postion") + ylab("Estimated effect")
      out <- gridExtra::grid.arrange(P1, P2, ncol = 1)
    }
    else {
      x <- rep(1:susiF.obj$n_wac, (susiF.obj$L + 1))
      CS <- rep(0:L, each = n_wac)
      df <- data.frame(fun_plot = fun_plot, CS = as.factor(CS),
                       x = x) %>%
        filter(CS != 0)
      P2 <- ggplot(df, aes_string(y = "fun_plot", x = "x", col = "CS")) +
        geom_line(size = size_line) + scale_color_manual("Credible set",
                                                         values = color[-1]) +
        geom_hline(yintercept=0, linetype='dashed', col = 'grey', size = 1.5)+
        facet_grid(CS~., scales = "free")+
        xlab("postion") + ylab("Estimated effect")

    }
  }
  else {
    if (effect > L) {
      stop(paste("the specified effect should be lower or equal to ",
                 L))
    }
    fun_plot <- susiF.obj$fitted_func[[effect]]
    fun_plot <- c(rep(0, n_wac), fun_plot)
    if (cred.band) {
      cred_band <- data.frame(t(susiF.obj$cred_band[[effect]]))
      cred_band <- rbind(data.frame(up = rep(0, n_wac),
                                    low = rep(0, n_wac)), cred_band)
      x <- rep(1:susiF.obj$n_wac, (1 + 1))
      CS <- rep(c(0, effect), each = n_wac)
      df <- data.frame(fun_plot = fun_plot, CS = as.factor(CS),
                       x = x, upr = cred_band$up, lwr = cred_band$low)
      P2 <- ggplot(df, aes_string(y = "fun_plot", x = "x", col = "CS")) +
        geom_line(size = 2) +
        geom_ribbon(aes_string(ymin = "lwr",ymax = "upr",fill = "CS",
                               col = "CS"),alpha = 0.3) +
        scale_color_manual("Credible set", values = color) +
        scale_fill_manual("Credible set", values = color) +
        xlab("postion") + ylab("Estimated effect")
      out <- P2
      return(P2)
    }
    else {
      x <- rep(1:susiF.obj$n_wac, (1 + 1))
      CS <- rep(c(0, effect), each = n_wac)
      df <- data.frame(fun_plot = fun_plot, CS = as.factor(CS),
                       x = x)
      P2 <- ggplot(df,aes_string(y = "fun_plot",x = "x",col = "CS")) +
        geom_line(size = 2) + scale_color_manual("Credible set",
                                                 values = color) + xlab("postion") + ylab("Estimated effect")
      out <- P2
      return(P2)
    }
  }
  # out
  # return(out)

  return(out <- gridExtra::grid.arrange(P1,P2,ncol=2,top =title))
}





#' @title Check tolerance for stopping criterion
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#' @param check numeric, dynamic value for testing outing of th while loop
#' @param cal_obj logical, if set to TRUE compute ELBO
#
#' @param X matrix of covariates
#
#' @param D matrix of wavelet D coefficients from the original input data (Y)
#
#' @param C vector of wavelet scaling coefficient from the original input data (Y)
#
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
#' @return a matrix of size N by size J of partial residuals
#' @export
#' @keywords internal
test_stop_cond <- function(susiF.obj,
                           check,
                           cal_obj,
                           Y,
                           X,
                           D,
                           C,
                           indx_lst
                           ,...)
  UseMethod("test_stop_cond")

#' @rdname test_stop_cond
#
#' @method test_stop_cond susiF
#
#' @export test_stop_cond.susiF
#
#' @export
#' @keywords internal
test_stop_cond.susiF <- function(susiF.obj, check, cal_obj, Y, X, D, C, indx_lst,...)
{

  if( susiF.obj$L==1)
  {
    susiF.obj$check <- 0
    return(susiF.obj)
  }

  if(!(susiF.obj$greedy_backfit_update)) #if not just updated check for stopping while loop
  {
    if( cal_obj){

      susiF.obj <- update_KL(susiF.obj,
                             X,
                             D= D,
                             C= C , indx_lst)

      susiF.obj <- update_ELBO(susiF.obj,
                               get_objective( susiF.obj = susiF.obj,
                                              Y         = Y,
                                              X         = X,
                                              D         = D,
                                              C         = C,
                                              indx_lst  = indx_lst
                               )
      )

      if(length(susiF.obj$ELBO)>1    )#update parameter convergence,
      {
        check <- abs(diff(susiF.obj$ELBO)[(length( susiF.obj$ELBO )-1)])
        susiF.obj$check <- check
        return(susiF.obj)
      }else{
        susiF.obj$check <- check
        return(susiF.obj)
      }
    }
    else{
      len <- length( susiF.obj$alpha_hist)
      if( len>1)#update parameter convergence, no ELBO for the moment
      {
        check <-0

        T1 <- do.call( rbind, susiF.obj$alpha_hist[[len ]])
        T1 <- T1[1:susiF.obj$L,] #might be longer than L because alpha computed before discarding effect
        T2 <- do.call( rbind, susiF.obj$alpha_hist[[(len-1) ]])


        if(!(susiF.obj$L==nrow(T2))){
          return(susiF.obj)
        }
        T2 <- T2[1:susiF.obj$L,]
        if(susiF.obj$L==1){
          T2 <- T2[1,]
        }

        if((nrow(T1)>nrow(T2))){
          susiF.obj$check <- 1
          return(susiF.obj)
        }
        if( (nrow(T2)>nrow(T1))){
          T2 <- T2[1:susiF.obj$L,]
        }


        check <- sum(abs(T1-T2))/nrow(X)
        susiF.obj$check <- check
        return(susiF.obj)
        #print(check)
      }else{
        susiF.obj$check <- check
        return(susiF.obj)
      }
    }
  }else{
    susiF.obj$check <- check
    return(susiF.obj)
  }

}





#' @title Update alpha   susiF mixture proportion of effect l
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
#' @param alpha  vector of p alpha values summing up to one
#
#' @return susiF object
#
#' @export
#' @keywords internal

update_alpha  <-  function(susiF.obj, l, alpha,... )
  UseMethod("update_alpha")


#' @rdname update_alpha
#
#' @method update_alpha susiF
#
#' @export update_alpha.susiF
#
#' @export
#' @keywords internal
update_alpha.susiF <-  function(susiF.obj, l, alpha,... )
{
  susiF.obj$alpha[[l]] <- alpha
   return( susiF.obj)
}

#' @title Update alpha_hist   susiF object
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#' @param  discard logical set to FALSE by default, if true remove element of history longer than L
#
#' @return susiF object
#
#' @export
#' @keywords internal

update_alpha_hist  <-  function(susiF.obj, discard,... )
  UseMethod("update_alpha_hist")


#' @rdname update_alpha_hist
#
#' @method update_alpha_hist susiF
#
#' @export update_alpha_hist.susiF
#
#' @export
#' @keywords internal
update_alpha_hist.susiF <-  function(susiF.obj , discard=FALSE,... )
{
    if(!discard){
        susiF.obj$alpha_hist[[ (length(susiF.obj$alpha_hist)+1)  ]] <- susiF.obj$alpha
    }
  if(discard){
    if((length(susiF.obj$alpha_hist[[length(susiF.obj$alpha_hist)]]) >susiF.obj$L)){

      tt <- susiF.obj$alpha_hist[[ (length(susiF.obj$alpha_hist) ) ]][1:susiF.obj$L]
      susiF.obj$alpha_hist[[ (length(susiF.obj$alpha_hist))  ]] <- tt
    }
  }

  return( susiF.obj)
}


# @title Update  susiF object using the output of EM_pi
#
# @description Update  susiF object using the output of EM_pi
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
# @param EM_pi an object of the class "EM_pi" generated by the function \code{\link{EM_pi}}
#
# @param Bhat matrix of estimated regression coefficients
#
# @param Shat  matrix of estimated standard errors
#
# @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
# @param lowc_wc list of wavelet coefficients that exhibit too little variance
#
# @param cal_wc_lsfr logical, set to TRUE if detailed output needed
#
# @return susiF object
#
# @export


update_susiF_obj  <- function(susiF.obj, l, EM_pi, Bhat, Shat, indx_lst, lowc_wc=NULL, cal_wc_lsfr=FALSE,...)
      UseMethod("update_susiF_obj")

# @rdname update_susiF_obj
#
# @method update_susiF_obj susiF
#
# @export update_susiF_obj.susiF
#
# @export
#

update_susiF_obj.susiF <- function(susiF.obj, l, EM_pi, Bhat, Shat, indx_lst, lowc_wc=NULL, cal_wc_lsfr=FALSE,...)
{

  if( l > length(susiF.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  if(  "EM_pi"  %!in%  class(EM_pi)  )
  {
    stop("Error EM_pi should be of the class EM_pi")
  }
  susiF.obj         <-   update_pi(susiF.obj = susiF.obj ,
                                   l = l ,
                                   tpi =  EM_pi$tpi_k)
  susiF.obj$G_prior <-   update_prior(get_G_prior(susiF.obj) , EM_pi$tpi_k  )

  if(!is.null(lowc_wc)){
    susiF.obj$fitted_wc[[l]][,-lowc_wc]   <- post_mat_mean(get_G_prior(susiF.obj) ,
                                                           Bhat,
                                                           Shat,
                                                           indx_lst = indx_lst,
                                                           lowc_wc  = lowc_wc)
    susiF.obj$fitted_wc2[[l]][,-lowc_wc]  <- post_mat_sd  (get_G_prior(susiF.obj) ,
                                                           Bhat,
                                                           Shat,
                                                           indx_lst = indx_lst,
                                                           lowc_wc  = lowc_wc)^2

  }else{
    susiF.obj$fitted_wc[[l]]   <- post_mat_mean(get_G_prior(susiF.obj) ,
                                                Bhat,
                                                Shat,
                                                indx_lst = indx_lst,
                                                lowc_wc  = lowc_wc)
    susiF.obj$fitted_wc2[[l]]  <- post_mat_sd  (get_G_prior(susiF.obj) ,
                                                Bhat,
                                                Shat,
                                                indx_lst = indx_lst,
                                                lowc_wc  = lowc_wc)^2
  }



  new_alpha <- cal_zeta(  EM_pi$lBF)
  susiF.obj <- update_alpha(susiF.obj, l, new_alpha)
  susiF.obj <- update_lBF  (susiF.obj, l, EM_pi$lBF)


  return(susiF.obj)
}

#' @title Update susiF by computing PiP
#
#' @param susiF.obj a susiF object defined by  init_susiF_obj  function
#' @return susiF object
#' @export
#' @keywords internal

update_cal_pip  <- function (susiF.obj,...)
  UseMethod("update_cal_pip")

#' @rdname update_cal_pip
#
#' @method update_cal_pip susiF
#
#' @export update_cal_pip.susiF
#
#' @export
#' @keywords internal

update_cal_pip.susiF <- function (susiF.obj,...)
{
  if(sum( is.na(unlist(susiF.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  tpip <- list()
  for ( l in 1:susiF.obj$L)
  {
    tpip[[l]] <- rep(1, lengths(susiF.obj$alpha)[[l]])-susiF.obj$alpha[[l]]
  }
  susiF.obj$pip <- 1-  apply( do.call(rbind,tpip),2, prod)
  return(susiF.obj)
}


#' @title Update susiF by computing credible sets
#
#' @param susiF.obj a susiF object defined by  init_susiF_obj  function
#
#' @param cov_lev numeric between 0 and 1, corresponding to the expected level of coverage of the cs if not specified set to 0.95
#
#' @return susiF object
#
#' @export
#' @keywords internal

update_cal_cs  <- function(susiF.obj, cov_lev=0.95,...)
  UseMethod("update_cal_cs")

#' @rdname update_cal_cs
#
#' @method update_cal_cs susiF
#
#' @export update_cal_cs.susiF
#
#' @export
#' @keywords internal

update_cal_cs.susiF <- function(susiF.obj, cov_lev=0.95,...)
{
  if(sum( is.na(unlist(susiF.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  for ( l in 1:susiF.obj$L)
  {
    temp        <- susiF.obj$alpha[[l]]
    temp_cumsum <- cumsum( temp[order(temp, decreasing =TRUE)])
    max_indx_cs <- min(which( temp_cumsum >cov_lev ))
    susiF.obj$cs[[l]]  <- order(temp, decreasing = TRUE)[1:max_indx_cs ]

  }

  return(susiF.obj)
}

#@title Update susiF by computing predicted curves
#
#@param susiF.obj a susiF object defined by init_susiF_obj function
#@param Y functional phenotype, matrix of size N by size J. The underlying algorithm uses wavelet which assume that J is of the form J^2. If J not a power of 2, susiF internally remaps the data into grid of length 2^J
#@param X matrix of size N by p
#@param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#@return susiF object
#@export
#

update_cal_indf <- function(susiF.obj, Y, X, indx_lst,...)
  UseMethod("update_cal_indf")

# @rdname update_cal_indf
#
# @method update_cal_indf susiF
#
# @export update_cal_indf.susiF
#
# @importFrom wavethresh wr
#
# @importFrom wavethresh wd
#
# @export
#

update_cal_indf.susiF <- function(susiF.obj, Y, X, indx_lst,...)
{
  mean_Y          <- attr(Y, "scaled:center")
  if(sum( is.na(unlist(susiF.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  temp <- wavethresh::wd(rep(0, susiF.obj$n_wac)) #create dummy wd object


  if(inherits(get_G_prior(susiF.obj),"mixture_normal_per_scale" ))
  {
    for ( i in 1:susiF.obj$N)
    {
      susiF.obj$ind_fitted_func[i,]  <- mean_Y#fitted_baseline future implementation
      for ( l in 1:susiF.obj$L)
      {
        #add wavelet coefficient
        temp$D                         <-    ( susiF.obj$alpha[[l]] *sweep(X, MARGIN=2, 1/(attr(X, "scaled:scale") ), '*')[i,])%*%susiF.obj$fitted_wc[[l]][,-indx_lst[[length(indx_lst)]]]
        temp$C[length(temp$C)]         <-    ( susiF.obj$alpha[[l]] *sweep(X, MARGIN=2, 1/(attr(X, "scaled:scale") ), '*')[i,])%*%susiF.obj$fitted_wc[[l]][,indx_lst[[length(indx_lst)]]]
        #transform back
        susiF.obj$ind_fitted_func[i,]  <-  susiF.obj$ind_fitted_func[i,]+wavethresh::wr(temp)
      }
    }
  }
  if(inherits(get_G_prior(susiF.obj),"mixture_normal" ))
  {
    for ( i in 1:susiF.obj$N)
    {
      susiF.obj$ind_fitted_func[i,]  <- mean_Y#fitted_baseline
      for ( l in 1:susiF.obj$L)
      {
        #add wavelet coefficient
        temp$D                         <-    (susiF.obj$alpha[[l]] *sweep(X, MARGIN=2, attr(X, "scaled:scale"), '*')[i,])%*%susiF.obj$fitted_wc[[l]][,-dim(susiF.obj$fitted_wc[[l]])[2]]
        temp$C[length(temp$C)]         <-    (susiF.obj$alpha[[l]] *sweep(X, MARGIN=2, attr(X, "scaled:scale"), '*')[i,]) %*%susiF.obj$fitted_wc[[l]][,dim(susiF.obj$fitted_wc[[l]])[2]]
        #transform back
        susiF.obj$ind_fitted_func[i,]  <-  susiF.obj$ind_fitted_func[i,]+wavethresh::wr(temp)
      }
    }
  }
  return( susiF.obj)
}



#' @title Update susiF by computing posterior curves
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#
#
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
#' @return susiF object
#
#' @export
#' @keywords internal
update_cal_fit_func  <- function(susiF.obj, indx_lst,...)
  UseMethod("update_cal_fit_func")

#' @rdname update_cal_fit_func
#
#' @method update_cal_fit_func susiF
#
#' @export update_cal_fit_func.susiF
#
#' @importFrom wavethresh wr
#
#' @importFrom wavethresh wd
#
#' @export
#' @keywords internal

update_cal_fit_func.susiF <- function(susiF.obj, indx_lst,...)
{

  if(sum( is.na(unlist(susiF.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  temp <- wavethresh::wd(rep(0, susiF.obj$n_wac))

  if(inherits(get_G_prior(susiF.obj),"mixture_normal_per_scale" ))
  {
    for ( l in 1:susiF.obj$L)
    {
      temp$D                     <- (susiF.obj$alpha[[l]])%*%sweep( susiF.obj$fitted_wc[[l]][,-indx_lst[[length(indx_lst)]]],
                                                                    1,
                                                                    1/(susiF.obj$csd_X ), "*")
      temp$C[length(temp$C)]     <- (susiF.obj$alpha[[l]])%*% (susiF.obj$fitted_wc[[l]][,indx_lst[[length(indx_lst)]]]*( 1/(susiF.obj$csd_X )))
      susiF.obj$fitted_func[[l]] <-  wavethresh::wr(temp)
    }
  }
  if(inherits(get_G_prior(susiF.obj),"mixture_normal" ))
  {
    for ( l in 1:susiF.obj$L)
    {
      temp$D                     <- (susiF.obj$alpha[[l]])%*%sweep(susiF.obj$fitted_wc[[l]][,-dim(susiF.obj$fitted_wc[[l]])[2]],
                                                                   1,
                                                                   1/(susiF.obj$csd_X ), "*")
      temp$C[length(temp$C)]     <- (susiF.obj$alpha[[l]])%*% (susiF.obj$fitted_wc[[l]][,dim(susiF.obj$fitted_wc[[l]])[2]]*( 1/(susiF.obj$csd_X )) )
      susiF.obj$fitted_func[[l]] <- wr(temp)
    }
  }
  return(susiF.obj)
}


# @title Update susiF by computing credible band for posterior curves
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
# @return susiF object
#
# @export
update_cal_credible_band  <- function(susiF.obj, indx_lst,...)
  UseMethod("update_cal_credible_band")

# @rdname  update_cal_credible_band
#
# @method  update_cal_credible_band susiF
#
# @export  update_cal_credible_band.susiF
#
# @importFrom wavethresh wr
#
# @importFrom wavethresh wd
# @importFrom wavethresh GenW
#
# @export
#

update_cal_credible_band.susiF <- function(susiF.obj, indx_lst,...)
{

  if(sum( is.na(unlist(susiF.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  temp <- wavethresh::wd(rep(0, susiF.obj$n_wac))


  for ( l in 1:susiF.obj$L)
  {
    Smat <- susiF.obj$fitted_wc2[[l]]
    W1   <- ((wavethresh::GenW(n=  ncol(Smat )  , filter.number = 10, family = "DaubLeAsymm")))
    tt   <- diag((W1)%*%diag(c(susiF.obj$alpha[[1]]%*%Smat ))%*% t(W1))

    up                       <-  susiF.obj$fitted_func[[l]]+ 1.96 *sqrt(tt)
    low                      <-  susiF.obj$fitted_func[[l]]- 1.96 *sqrt(tt)
    susiF.obj$cred_band[[l]] <- rbind(up, low)
  }



  return(susiF.obj)
}


# @title Update susiF by computing posterior curves using wavelet coefficient with a low lfsr
#
# @param susiF.obj a susiF object defined by init_susiF_obj function
#
# @param lfsr_curve Maximum local false sign rate of the wavelet coefficients used to reconstruct lfsr_curves (see output)
#
# @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
# @return susiF object
#
# @export
update_cal_lfsr_func  <- function(susiF.obj, lfsr_curve,  indx_lst,...)
  UseMethod("update_cal_lfsr_func")

# @rdname update_cal_lfsr_func
#
# @method update_cal_lfsr_func susiF
#
# @export update_cal_lfsr_func.susiF
#
# @importFrom wavethresh wr
#
# @importFrom wavethresh wd
#
# @export
#

update_cal_lfsr_func.susiF <- function(susiF.obj, lfsr_curve, indx_lst,...)
{

  if(sum( is.na(unlist(susiF.obj$alpha))))
  {
    stop("Error: some alpha value not updated, please update alpha value first")
  }
  temp <- wavethresh::wd(rep(0, susiF.obj$n_wac))

  if(inherits(get_G_prior(susiF.obj),"mixture_normal_per_scale" ))
  {
    for ( l in 1:susiF.obj$L)
    {
      wc_to_select <- ifelse(susiF.obj$lfsr_wc[[l]] < lfsr_curve,1,0)
      t_wc <- susiF.obj$fitted_wc[[l]]%*% diag(wc_to_select)
      temp$D                     <- (susiF.obj$alpha[[l]])%*%t_wc[,-indx_lst[[length(indx_lst)]]]
      temp$C[length(temp$C)]     <- (susiF.obj$alpha[[l]])%*%t_wc[,indx_lst[[length(indx_lst)]]]
      susiF.obj$lfsr_func[[l]] <-  wavethresh::wr(temp)
    }
  }
  if(inherits(get_G_prior(susiF.obj),"mixture_normal" ))
  {
    for ( l in 1:susiF.obj$L)
    {
      wc_to_select <- ifelse(susiF.obj$lfsr_wc[[l]] < lfsr_curve,1,0)
      t_wc <- susiF.obj$fitted_wc[[l]]%*% diag(wc_to_select)
      temp$D                     <- (susiF.obj$alpha[[l]])%*%t_wc[,-dim(susiF.obj$fitted_wc[[l]])[2]]
      temp$C[length(temp$C)]     <- (susiF.obj$alpha[[l]])%*%t_wc[,dim(susiF.obj$fitted_wc[[l]])[2]]
      susiF.obj$lfsr_func[[l]] <- wr(temp)
    }
  }
  return(susiF.obj)
}






#' @title Update susiF log Bayes factor
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#' @param l effect to update
#' @param lBF vector of length p, containing the updated log Bayes factors
#' @return susiF object
#' @export
#' @keywords internal


update_lBF  <- function    (susiF.obj, l, lBF,...)
  UseMethod("update_lBF")

#' @rdname update_lBF
#
#' @method update_lBF susiF
#
#' @export update_lBF.susiF
#
#' @export
#' @keywords internal


update_lBF.susiF <- function    (susiF.obj,l, lBF,...)
{
  if(l> susiF.obj$L)
  {
    stop("Error: trying to update more effects than the number of specified effect")
  }

  susiF.obj$lBF[[l]] <- lBF
  return(susiF.obj)
}




#@title Update susiF local False Sign Rate
#
#@param susiF.obj a susiF object defined by init_susiF_obj function
#
#@param l effect to update
#
# @param Bhat  matrix pxJ regression coefficient, Bhat[j,t] corresponds to regression coefficient of Y[,t] on X[,j]
#
# @param Shat matrix pxJ standard error, Shat[j,t] corresponds to standard error of the regression coefficient of Y[,t] on X[,j]
#
#@param alpha  vector of length p, containing the updated log Bayes factors
# @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#@return susiF object
#@export

update_lfsr  <- function    (susiF.obj, l, Bhat, Shat, alpha, indx_lst,...)
  UseMethod("update_lfsr")

# @rdname update_lfsr
#
# @method update_lfsr susiF
#
# @export update_lfsr.susiF
#
# @export
#

update_lfsr.susiF <- function(susiF.obj, l, Bhat, Shat, alpha, indx_lst,...)
{
  clfsr_wc <-  cal_clfsr(get_G_prior(susiF.obj),  Bhat,Shat,indx_lst )
  susiF.obj$lfsr_wc[[l]] <- cal_lfsr (clfsr_wc,alpha)
  return(susiF.obj)
}




#' @title Update susiF log Bayes factor
#
#' @param susiF.obj a susiF object defined by init_susiF_obj function
#' @param  ELBO new ELBO value
#' @return susiF object
#' @export
#' @keywords internal


update_ELBO  <- function    (susiF.obj,ELBO ,...)
  UseMethod("update_ELBO")

#' @rdname update_ELBO
#
#' @method update_ELBO susiF
#
#' @export update_ELBO.susiF
#
#' @export
#' @keywords internal


update_ELBO.susiF <- function    (susiF.obj,ELBO,...)
{

  susiF.obj$ELBO <- c(susiF.obj$ELBO,ELBO)
  return(susiF.obj)
}

#' @title Compute KL divergence effect l
#'  @param susiF.obj a susiF object
#' @param X matrix of covariates
#
#' @param D matrix of wavelet D coefficients from the original input data (Y)
#
#' @param C vector of wavelet scaling coefficient from the original input data (Y)
#
#' @param indx_lst list generated by gen_wavelet_indx for the given level of resolution
#
#' @return susiF object
#' @export
#' @keywords internal

update_KL <- function(susiF.obj,   X, D, C , indx_lst,...)
  UseMethod("update_KL")



#' @rdname update_KL
#
#' @method update_KL susiF
#
#' @export update_KL.susiF
#
#' @export
#' @keywords internal
#

update_KL.susiF <- function(susiF.obj,  X, D, C , indx_lst,...)
{

  susiF.obj$KL <-  do.call(c,lapply(1:susiF.obj$L,FUN=function(l) cal_KL_l(susiF.obj=susiF.obj,
                                                                           l=l,
                                                                           X=X,
                                                                           D=D,
                                                                           C=C,
                                                                           indx_lst =indx_lst )))
  return( susiF.obj)
}





# @title Update mixture proportion of susiF mixture proportions of effect l
#
# @param susiF.obj a susif object defined by init_susiF_obj function
#
# @param l integer larger or equal to 1. Corresponds to the effect to be accessed
#
# @param tpi an object of the class "pi_mixture_normal" or "pi_mixture_normal_per_scale"
#
# @return susiF object
#
# @export

update_pi <- function( susiF.obj, l, tpi,...)
  UseMethod("update_pi")

# @rdname update_pi
#
# @method update_pi susiF
#
# @export update_pi.susiF
#
# @export
#
update_pi.susiF <- function( susiF.obj, l, tpi,...)
{

  if( l > length(susiF.obj$est_pi))
  {
    stop("Error trying to access mixture proportion")
  }
  if( l < 1)
  {
    stop("Error l should be larger ")
  }
  if( class(tpi)%!in% c("pi_mixture_normal" , "pi_mixture_normal_per_scale"))
  {
    stop("Error tpi should be of one of the follwoing class:\n
          pi_mixture_normal \n pi_mixture_normal_per_scale")
  }
  susiF.obj$est_pi[[l]] <- tpi
  out <- susiF.obj
  class(out) <- "susiF"
  return(out)
}





#' @title Update residual variance
#' @description  See title
#' @param susiF.obj a susiF object
#' @param sigma2 the new value for residual variance
#' @export
#' @keywords internal

update_residual_variance  <- function(susiF.obj,sigma2,...)
  UseMethod("update_residual_variance")

#' @rdname update_residual_variance
#
#' @method update_residual_variance susiF
#
#' @export update_residual_variance.susiF
#
#' @export
#' @keywords internal

update_residual_variance.susiF <- function(susiF.obj,sigma2,...)
{
  susiF.obj$sigma2 <- sigma2
  return(susiF.obj)
}



#
#' @title Return which credible sets are  dummy
#
#' @param susiF.obj a susif object defined by init_susiF_obj function
#' @param min.purity minimal purity within a CS
#' @param X matrix of covariates
#
#' @return a list of index corresponding the the dummy effect
#
#' @export
#' @keywords internal
which_dummy_cs <- function(susiF.obj, min.purity=0.5,X,...)
  UseMethod("which_dummy_cs")



#' @rdname which_dummy_cs
#
#' @method which_dummy_cs susiF
#
#' @export which_dummy_cs.susiF
#' @export
#' @keywords internal
which_dummy_cs.susiF <- function(susiF.obj, min.purity=0.5,X,...){
  dummy.cs<- c()
if( susiF.obj$L==1){
  return(dummy.cs)
}

  if( inherits( susiF.obj$G_prior,"mixture_normal"))
  {
    for (l in 1:susiF.obj$L )
    {

      if (length(susiF.obj$cs[[l]])==1)
      {

        if( susiF.obj$est_pi[[l]][1]==1){# check if the estimated prior is exactly 0

          dummy.cs<-  c( dummy.cs,l)
        }

      }else{

        if( min(cor( X[,susiF.obj$cs[[l]]])) <  min.purity){#check if the purity of cs l is lower that min.purity

          dummy.cs<-  c( dummy.cs,l)

        }else{
          if(susiF.obj$est_pi[[l]][1]==1){
            dummy.cs<-  c( dummy.cs,l)
          }

        }
      }

    }
    if( length(dummy.cs)==0)
    {
      return(dummy.cs)
    }else{
      if(length(dummy.cs)==susiF.obj$L) #avoid returning empty results
      {
        dummy.cs <- dummy.cs[-1]
      }

      return(dummy.cs)
    }
  }


  if(inherits(susiF.obj$G_prior,"mixture_normal_per_scale"))
  {
    for (l in 1:susiF.obj$L )
    {

      if (length(susiF.obj$cs[[l]])==1)
      {

        if(  mean(sapply(susiF.obj$est_pi[[l]],"[[",1))==1){# check if the estimated prior is exactly 0

          dummy.cs<-  c( dummy.cs,l)
        }

      }else{

        if( min(cor( X[,susiF.obj$cs[[l]]])) <  min.purity){#check if the purity of cs l is lower that min.purity

          dummy.cs<-  c( dummy.cs,l)

        }else{
          if(  mean(sapply(susiF.obj$est_pi[[l]],"[[",1))==1){
            dummy.cs<-  c( dummy.cs,l)
          }

        }
      }

    }
    if( length(dummy.cs)==0)
    {
      return(dummy.cs)
    }else{
      if(length(dummy.cs)==susiF.obj$L) #avoid returning empty results
      {
        dummy.cs <- dummy.cs[-1]
      }

      return(dummy.cs)
    }
  }

}

